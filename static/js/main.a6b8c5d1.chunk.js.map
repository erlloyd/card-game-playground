{"version":3,"sources":["../node_modules/peerjs/dist sync","constants/card-constants.ts","CardTokens.tsx","features/cards/cards.selectors.ts","CardTokensContainer.tsx","constants/app-constants.ts","Card.tsx","ContextMenu.tsx","DeckLoader.tsx","EncounterLoader.tsx","features/cards-data/cards-data.selectors.ts","EncounterLoaderContainer.tsx","utilities/geo.ts","store/localStorage.ts","features/cards/initialState.ts","features/cards/cards.slice.ts","features/cards/cards.actions.ts","features/cards/cards.thunks.ts","store/global.actions.ts","TopLayer.tsx","CardStackCardSelector.tsx","CardStackCardSelectorContainer.tsx","Counter.tsx","PeerConnector.tsx","App.tsx","features/cards-data/cards-data.slice.ts","features/cards-data/initialState.ts","features/game/game.selectors.ts","features/game/initialState.ts","features/game/game.slice.ts","features/counters/counters.actions.ts","features/counters/initialState.ts","features/counters/counters.slice.ts","features/counters/counters.selectors.ts","AppContainer.tsx","features/counters/counters.thunks.ts","serviceWorker.ts","store/rootReducer.ts","store/peer-js-redux-middleware.ts","store/configureStore.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","cardConstants","CardTokens","props","damageImg","threatImg","genericImg","unmounted","state","imagesLoaded","damage","threat","generic","Image","onload","setState","card","counterTokens","src","process","prevProps","prevState","this","damageX","x","naturalWidth","damageY","y","showDamage","damageToken","width","height","naturalHeight","fillPatternImage","damageText","text","fill","align","verticalAlign","fontSize","threatX","threatY","showThreat","threatToken","threatText","genericX","genericY","showGeneric","Component","getCards","cards","present","getCardMapById","createSelector","reduce","map","shouldShowPreview","previewCard","every","dragging","getPanMode","panMode","CardTokensContainer","connect","myPeerRef","uuidv4","HORIZONTAL_TYPE_CODES","stringArraysEqual","array1","array2","length","value","index","Card","imgs","stunnedImg","confusedImg","toughImg","initCardImages","imgUrls","forEach","img","imageLoaded","onerror","imageLoadFailed","imgUrl","renderUnanimatedCard","heightToUse","widthToUse","imgToUse","find","i","complete","undefined","scale","getScale","offset","native","rotation","exhausted","cornerRadius","stroke","dropTarget","strokeWidth","fillPatternRotation","shouldRenderImageHorizontal","typeCode","fillPatternScaleX","fillPatternScaleY","shadowColor","controlledBy","selectedColor","shadowBlur","selected","opacity","isGhost","draggable","onDragStart","handleDragStart","onDragMove","handleDragMove","onDragEnd","handleDragEnd","onDblClick","handleDoubleClick","onDblTap","onClick","handleClick","onTap","onMouseDown","handleMouseDown","onTouchStart","onMouseOver","handleMouseOver","onMouseOut","handleMouseOut","onContextMenu","handleContextMenu","cardStackOffset","cardStack","numCardsInStack","shouldRenderStunned","cardState","stunned","tokenImagesLoaded","stunnedToken","getTokenInSlot","confusedToken","confused","toughToken","tough","cardTokens","renderCardName","event","dx","target","dy","cancelBubble","handleHover","handleHoverLeave","prevImgUrls","renderCard","cardWidth","cardHeight","textOffset","name","shouldRender","slot","dimensions","stunnedOffset","type","typeCodes","includes","plainCardBack","widthHorizontal","heightHorizontal","some","ContextMenu","preventDefault","handleContextItemClicked","item","action","contextItemClicked","items","hideContextMenu","Menu","keepMounted","open","onClose","anchorReference","anchorPosition","top","position","left","MenuItem","label","DeckLoader","stopPropagation","handleKeyDown","key","loadDeckId","currentTarget","onKeyDown","EncounterLoader","handleSelected","_event","loadCards","c","Autocomplete","options","encounterData","getOptionLabel","option","setData","style","onChange","renderInput","params","TextField","variant","getCardsData","cardsData","getCardsDataEntities","entities","encounterEntities","getCardsDataHeroEntities","getCardsDataEncounterEntities","getCardsDataSetData","getCardsDataEncounterEntitiesBySetCode","setTypesEncounters","Object","values","encounterCard","setCode","set_code","push","entries","filter","set","setTypeCode","sort","a","b","EncounterLoaderContainer","getDistance","point1","point2","deltaX","deltaY","Math","sqrt","loadState","serializedState","localStorage","getItem","baseState","JSON","parse","err","console","error","localStorageState","StatusTokenType","CounterTokenType","initialState","ghostCards","dropTargetCard","addCardStackWithId","createAction","pullCardOutOfCardStackWithId","startCardMoveWithSplitStackId","replaceCardStack","fetchDecklistById","createAsyncThunk","payload","thunkApi","axios","get","decklistId","response","getState","heroCardsData","heroSetCode","data","investigator_code","encounterCardsData","heroObligationDeck","type_code","heroEncounterDeck","heroId","dataId","relatedEncounterDeck","encounterDeckId","relatedObligationDeck","obligationDeckId","shuffle","array","temporaryValue","randomIndex","returnArray","stringify","currentIndex","floor","random","resetApp","receiveRemoteGameState","getCardStackWithId","mutateCardWithId","ref","callback","cardToUpdate","unselectAllCardsReducer","ACTOR_REF","cardsSlice","createSlice","reducers","selectCard","unselectOtherCards","unselectCard","toggleSelectCard","exhaustCard","cardMove","primaryCard","movedCards","possibleDropTargets","foreachUnselectedCard","distance","c1","c2","movedCard","splice","indexOf","endCardMove","dropTargetCards","concat","selectMultipleCards","ids","unselectAllCards","hoverCard","cardToPreview","faceup","hoverLeaveCard","togglePanMode","flipCards","reverse","resetCards","toggleToken","cardToToggle","statusTokens","tokenType","adjustCounterToken","delta","extraReducers","builder","addCase","cardToReplaceStack","newStack","cardJsonIds","jsonId","cardStackToUse","cardStackId","newCardStack","newCard","assign","cardToStartMoving","splitTopCard","cardToMove","topCard","shift","splitCardId","actorRef","foreachSelectedAndControlledCard","fulfilled","log","heroCard","mainDeckStack","slots","cardDetails","Array","from","cardPadding","newDeck","encounterDeck","obligationDeck","actions","TopLayer","completed","containerStyle","className","children","CardStackCardSelector","cardsDataInStack","cardSelected","cardsDataEntities","CardStackCardSelectorContainer","Counter","handleDecrement","updateCounterValueBy","handleIncrement","pos","PeerConnector","inputRef","App","stage","handleCounterValueUpdate","updateCounterValue","handleCounterDrag","moveCounter","newPos","noOp","renderEmptyMessage","renderContextMenu","showContextMenu","containerRect","container","getBoundingClientRect","pointerPosition","contextMenuPosition","contextMenuItems","clearContextMenu","renderDeckImporter","showDeckImporter","deckImporterPosition","clearDeckImporter","handleImportDeck","getRelativePositionFromTarget","renderEncounterImporter","showEncounterImporter","encounterImporterPosition","clearEncounterImporter","handleLoadEncounter","renderCardSearch","showCardSearch","cardSearchPosition","cardStackForSearching","clearCardSearch","handleCardSelectedFromCardStack","renderPeerConnector","showPeerConnector","peerConnectorPosition","clearPeerConnector","handlePeerConnect","addCardStack","peerId","connectToRemoteGame","pullCardOutOfCardStack","handleStageClickOrTap","mousePos","selectStartPos","handleWheel","evt","oldScale","gameState","stageZoom","pointer","getPointerPosition","mousePointTo","newScale","updateZoom","updatePosition","handleCounterContextMenu","counterId","menuItems","removeCounter","handleCardContextMenu","cardId","currentStatusTokens","shuffleStack","Stunned","Confused","Tough","Damage","Threat","Generic","handleCardClick","modifierKeyHeld","shiftKey","metaKey","ctrlKey","handleSelectAndExhaust","handleCardDragStart","draggingCard","hasStack","upperRightPoint","startCardMove","handleKeyPress","which","keyCode","redo","undo","getRawPreviewCardPosition","pointerPos","screenMidPointX","window","innerWidth","posParam","transform","getAbsoluteTransform","copy","invert","point","button","selecting","getSelectionRectInfo","selectRect","abs","handleMouseUp","drewASelectionRect","selectedCards","currSelectedCards","Intersects","handleMouseMove","addNewCounter","getCardType","getCardName","cardInQuestion","getImgUrls","topCardData","bottomCardData","back_link","double_sided","octgn_id","loadCardsData","staticCards","playerColors","tokens","movingCards","previewCards","showPreview","rawPos","previewPos","tabIndex","onKeyPress","Consumer","store","stagePosition","innerHeight","onMouseUp","onMouseMove","onTouchMove","onWheel","counters","counter","cardsDataSlice","heroPacks","PackData","encounterPacks","pack","SetData","card_set_type_code","getGame","game","getPlayerColors","gameSlice","setPlayerColor","color","addNewCounterWithId","countersSlice","getCurrentCounters","AppContainer","dispatch","payloadWithId","stackToShuffle","shuffledStack","ActionCreators","Boolean","location","hostname","match","rootReducer","combineReducers","undoable","limit","groupBy","groupByActionTypes","excludeAction","blacklistRemoteActions","setupConnection","conn","storeAPI","on","INITIAL_STATE_MSG","setTimeout","REMOTE_ACTION","customizedMiddleware","getDefaultMiddleware","thunk","immutableCheck","serializableCheck","activeCon","cgpPeer","Peer","debug","send","setPlayerColorAction","metadata","peerConnection","onconnectionstatechange","ev","connectionState","next","rtkConfigureStore","reducer","middleware","devTools","subscribe","throttle","blacklistStateKeys","setItem","saveState","configureStore","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.a6b8c5d1.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 252;","export const cardConstants = {\n  CARD_HEIGHT: 209,\n  CARD_WIDTH: 150,\n  CARD_PREVIEW_HEIGHT: 418,\n  CARD_PREVIEW_WIDTH: 300,\n};\n","import { Component } from \"react\";\nimport * as React from \"react\";\nimport { ICardStack } from \"./features/cards/initialState\";\nimport { Rect, Text } from \"react-konva\";\nimport { cardConstants } from \"./constants/card-constants\";\ninterface IProps {\n  x: number;\n  y: number;\n  card: ICardStack;\n}\n\ninterface IState {\n  imagesLoaded: {\n    damage: boolean;\n    threat: boolean;\n    generic: boolean;\n  };\n}\n\nclass CardTokens extends Component<IProps, IState> {\n  private damageImg: HTMLImageElement;\n  private threatImg: HTMLImageElement;\n  private genericImg: HTMLImageElement;\n  private unmounted: boolean;\n\n  constructor(props: IProps) {\n    super(props);\n\n    this.unmounted = true;\n\n    this.state = {\n      imagesLoaded: {\n        damage: false,\n        threat: false,\n        generic: false,\n      },\n    };\n\n    this.damageImg = new Image();\n    this.threatImg = new Image();\n    this.genericImg = new Image();\n\n    // DAMAGE\n    this.damageImg.onload = () => {\n      if (!this.unmounted) {\n        this.setState({\n          imagesLoaded: {\n            damage: true,\n            threat: this.state.imagesLoaded.threat,\n            generic: this.state.imagesLoaded.generic,\n          },\n        });\n      }\n    };\n\n    if (!!this.props.card.counterTokens.damage) {\n      this.damageImg.src =\n        process.env.PUBLIC_URL + \"/images/standard/damage.png\";\n    }\n\n    // THREAT\n    this.threatImg.onload = () => {\n      if (!this.unmounted) {\n        this.setState({\n          imagesLoaded: {\n            damage: this.state.imagesLoaded.damage,\n            threat: true,\n            generic: this.state.imagesLoaded.generic,\n          },\n        });\n      }\n    };\n\n    if (!!this.props.card.counterTokens.threat) {\n      this.threatImg.src =\n        process.env.PUBLIC_URL + \"/images/standard/threat.png\";\n    }\n\n    // GENERIC\n    this.genericImg.onload = () => {\n      if (!this.unmounted) {\n        this.setState({\n          imagesLoaded: {\n            damage: this.state.imagesLoaded.damage,\n            threat: this.state.imagesLoaded.threat,\n            generic: true,\n          },\n        });\n      }\n    };\n\n    if (!!this.props.card.counterTokens.generic) {\n      this.genericImg.src =\n        process.env.PUBLIC_URL + \"/images/standard/generic_counter.png\";\n    }\n  }\n\n  public componentDidUpdate(prevProps: IProps, prevState: IState) {\n    // DAMAGE\n    if (\n      !this.state.imagesLoaded.damage &&\n      !prevProps.card?.counterTokens.damage &&\n      !!this.props.card?.counterTokens.damage\n    ) {\n      this.damageImg.src =\n        process.env.PUBLIC_URL + \"/images/standard/damage.png\";\n    }\n\n    // THREAT\n    if (\n      !this.state.imagesLoaded.threat &&\n      !prevProps.card?.counterTokens.threat &&\n      !!this.props.card?.counterTokens.threat\n    ) {\n      this.threatImg.src =\n        process.env.PUBLIC_URL + \"/images/standard/threat.png\";\n    }\n\n    // DAMAGE\n    if (\n      !this.state.imagesLoaded.generic &&\n      !prevProps.card?.counterTokens.generic &&\n      !!this.props.card?.counterTokens.generic\n    ) {\n      this.genericImg.src =\n        process.env.PUBLIC_URL + \"/images/standard/generic_counter.png\";\n    }\n  }\n\n  public componentDidMount() {\n    this.unmounted = false;\n  }\n\n  public componentWillUnmount() {\n    this.unmounted = true;\n  }\n\n  render() {\n    const damageX = this.props.x - this.damageImg.naturalWidth / 2;\n    const damageY = this.props.y - cardConstants.CARD_HEIGHT / 2 + 20;\n    const showDamage =\n      this.state.imagesLoaded.damage && !!this.props.card.counterTokens.damage;\n\n    const damageToken = showDamage ? (\n      <Rect\n        key={`${this.props.card.id}-damageToken`}\n        x={damageX}\n        y={damageY}\n        width={this.damageImg.naturalWidth}\n        height={this.damageImg.naturalHeight}\n        fillPatternImage={this.damageImg}\n      ></Rect>\n    ) : null;\n\n    const damageText = showDamage ? (\n      <Text\n        key={`${this.props.card.id}-damageText`}\n        x={damageX}\n        y={damageY}\n        width={this.damageImg.naturalWidth}\n        height={this.damageImg.naturalHeight}\n        text={`${this.props.card.counterTokens.damage}`}\n        fill=\"white\"\n        align=\"center\"\n        verticalAlign=\"middle\"\n        fontSize={24}\n      ></Text>\n    ) : null;\n\n    const threatX = this.props.x - this.threatImg.naturalWidth / 2;\n    const threatY = damageY + this.damageImg.naturalHeight + 5;\n    const showThreat =\n      this.state.imagesLoaded.threat && !!this.props.card.counterTokens.threat;\n\n    const threatToken = showThreat ? (\n      <Rect\n        key={`${this.props.card.id}-threatToken`}\n        x={threatX}\n        y={threatY}\n        width={this.threatImg.naturalWidth}\n        height={this.threatImg.naturalHeight}\n        fillPatternImage={this.threatImg}\n      ></Rect>\n    ) : null;\n\n    const threatText = showThreat ? (\n      <Text\n        key={`${this.props.card.id}-threatText`}\n        x={threatX}\n        y={threatY}\n        width={this.threatImg.naturalWidth}\n        height={this.threatImg.naturalHeight}\n        text={`${this.props.card.counterTokens.threat}`}\n        fill=\"white\"\n        align=\"center\"\n        verticalAlign=\"middle\"\n        fontSize={24}\n      ></Text>\n    ) : null;\n\n    const genericX = this.props.x - this.threatImg.naturalWidth / 2;\n    const genericY = threatY + this.threatImg.naturalHeight + 5;\n    const showGeneric =\n      this.state.imagesLoaded.generic &&\n      !!this.props.card.counterTokens.generic;\n\n    const genericToken = showGeneric ? (\n      <Rect\n        key={`${this.props.card.id}-genericToken`}\n        x={genericX}\n        y={genericY}\n        width={this.genericImg.naturalWidth}\n        height={this.genericImg.naturalHeight}\n        fillPatternImage={this.genericImg}\n      ></Rect>\n    ) : null;\n\n    const genericText = showGeneric ? (\n      <Text\n        key={`${this.props.card.id}-genericText`}\n        x={genericX}\n        y={genericY}\n        width={this.genericImg.naturalWidth}\n        height={this.genericImg.naturalHeight}\n        text={`${this.props.card.counterTokens.generic}`}\n        fill=\"white\"\n        align=\"center\"\n        verticalAlign=\"middle\"\n        fontSize={24}\n      ></Text>\n    ) : null;\n\n    return [\n      damageToken,\n      damageText,\n      threatToken,\n      threatText,\n      genericToken,\n      genericText,\n    ];\n  }\n}\n\nexport default CardTokens;\n","import { createSelector } from \"@reduxjs/toolkit\";\nimport { RootState } from \"../../store/rootReducer\";\nimport { ICardStack } from \"./initialState\";\n\nexport const getCards = (state: RootState) => state.cards.present;\n\nexport const getCardMapById = createSelector(getCards, (cards) => {\n  return cards.cards.reduce((map: { [k: string]: ICardStack }, card) => {\n    map[card.id] = card;\n    return map;\n  }, {});\n});\n\nexport const shouldShowPreview = createSelector(getCards, (cards) => {\n  return !!cards.previewCard && cards.cards.every((card) => !card.dragging);\n});\n\nexport const getPanMode = (state: RootState) => state.cards.present.panMode;\n","import { connect } from \"react-redux\";\n\nimport { RootState } from \"./store/rootReducer\";\nimport CardTokens from \"./CardTokens\";\nimport { getCardMapById } from \"./features/cards/cards.selectors\";\n\nexport interface IProps {\n  id: string;\n}\n\nconst mapStateToProps = (state: RootState, props: IProps) => {\n  return {\n    card: getCardMapById(state)[props.id],\n  };\n};\n\nconst CardTokensContainer = connect(mapStateToProps, {})(CardTokens);\n\nexport default CardTokensContainer;\n","import { v4 as uuidv4 } from \"uuid\";\n\nexport const myPeerRef = uuidv4();\n\nexport type PlayerColor =\n  | \"red\"\n  | \"cyan\"\n  | \"green\"\n  | \"blue\"\n  | \"magnenta\"\n  | \"yellow\";\n\nexport const possibleColors: PlayerColor[] = [\n  \"red\",\n  \"cyan\",\n  \"green\",\n  \"blue\",\n  \"magnenta\",\n  \"yellow\",\n];\n","// tslint:disable:no-console\nimport { KonvaEventObject } from \"konva/types/Node\";\nimport { Vector2d } from \"konva/types/types\";\nimport * as React from \"react\";\nimport { Component } from \"react\";\nimport { Rect, Text } from \"react-konva\";\nimport CardTokensContainer from \"./CardTokensContainer\";\nimport { myPeerRef, PlayerColor } from \"./constants/app-constants\";\nimport { cardConstants } from \"./constants/card-constants\";\n\nexport const HORIZONTAL_TYPE_CODES = [\"main_scheme\", \"side_scheme\"];\n\nexport interface CardTokens {\n  damage: number;\n  threat: number;\n  generic: number;\n}\n\nexport interface CardUIState {\n  stunned: boolean;\n  confused: boolean;\n  tough: boolean;\n  tokens: CardTokens;\n}\n\ninterface IProps {\n  name: string;\n  selectedColor: PlayerColor;\n  controlledBy: string;\n  dragging: boolean;\n  exhausted: boolean;\n  cardState?: CardUIState;\n  fill: string;\n  handleClick?: (id: string, event: KonvaEventObject<MouseEvent>) => void;\n  handleDoubleClick?: (id: string, event: KonvaEventObject<MouseEvent>) => void;\n  handleDragStart?: (id: string, event: KonvaEventObject<DragEvent>) => void;\n  handleDragMove?: (info: { id: string; dx: number; dy: number }) => void;\n  handleDragEnd?: (id: string) => void;\n  handleHover?: (id: string) => void;\n  handleHoverLeave?: (id: string) => void;\n  id: string;\n  selected: boolean;\n  dropTarget?: boolean;\n  x: number;\n  y: number;\n  width?: number;\n  height?: number;\n  imgUrls: string[];\n  isGhost?: boolean;\n  numCardsInStack?: number;\n  typeCode?: string;\n  faceup: boolean;\n  handleContextMenu?: (\n    id: string,\n    event: KonvaEventObject<PointerEvent>\n  ) => void;\n}\n\ninterface IState {\n  imageLoaded: boolean;\n  imageLoadFailed: number;\n  prevImgUrls: string[];\n  tokenImagesLoaded: {\n    stunned: boolean;\n    confused: boolean;\n    tough: boolean;\n  };\n}\n\nconst stringArraysEqual = (array1: string[], array2: string[]) => {\n  return (\n    array1.length === array2.length &&\n    array1.every((value, index) => {\n      return value === array2[index];\n    })\n  );\n};\n\nclass Card extends Component<IProps, IState> {\n  // tslint:disable-next-line:member-access\n  static getDerivedStateFromProps(props: IProps, state: IState): IState | null {\n    if (!stringArraysEqual(props.imgUrls, state.prevImgUrls ?? [])) {\n      return {\n        imageLoaded: false,\n        imageLoadFailed: 0,\n        prevImgUrls: props.imgUrls,\n        tokenImagesLoaded: {\n          stunned: state.tokenImagesLoaded.stunned,\n          confused: state.tokenImagesLoaded.confused,\n          tough: state.tokenImagesLoaded.tough,\n        },\n      };\n    }\n    // No state update necessary\n    return null;\n  }\n\n  private imgs: HTMLImageElement[] = [];\n  private stunnedImg: HTMLImageElement;\n  private confusedImg: HTMLImageElement;\n  private toughImg: HTMLImageElement;\n  private unmounted: boolean;\n\n  constructor(props: IProps) {\n    super(props);\n\n    this.unmounted = true;\n\n    this.state = {\n      imageLoaded: false,\n      imageLoadFailed: 0,\n      prevImgUrls: this.props.imgUrls,\n      tokenImagesLoaded: {\n        stunned: false,\n        confused: false,\n        tough: false,\n      },\n    };\n\n    this.initCardImages(props);\n\n    this.stunnedImg = new Image();\n    this.confusedImg = new Image();\n    this.toughImg = new Image();\n\n    // STUNNED\n    this.stunnedImg.onload = () => {\n      if (!this.unmounted) {\n        this.setState({\n          tokenImagesLoaded: {\n            stunned: true,\n            confused: this.state.tokenImagesLoaded.confused,\n            tough: this.state.tokenImagesLoaded.tough,\n          },\n        });\n      }\n    };\n\n    if (!!props.cardState?.stunned) {\n      this.stunnedImg.src =\n        process.env.PUBLIC_URL + \"/images/standard/stunned.png\";\n    }\n\n    // CONFUSED\n    this.confusedImg.onload = () => {\n      if (!this.unmounted) {\n        this.setState({\n          tokenImagesLoaded: {\n            stunned: this.state.tokenImagesLoaded.stunned,\n            confused: true,\n            tough: this.state.tokenImagesLoaded.tough,\n          },\n        });\n      }\n    };\n\n    if (!!props.cardState?.confused) {\n      this.confusedImg.src =\n        process.env.PUBLIC_URL + \"/images/standard/confused.png\";\n    }\n\n    // TOUGH\n    this.toughImg.onload = () => {\n      if (!this.unmounted) {\n        this.setState({\n          tokenImagesLoaded: {\n            stunned: this.state.tokenImagesLoaded.stunned,\n            confused: this.state.tokenImagesLoaded.confused,\n            tough: true,\n          },\n        });\n      }\n    };\n\n    if (!!props.cardState?.tough) {\n      this.toughImg.src = process.env.PUBLIC_URL + \"/images/standard/tough.png\";\n    }\n  }\n\n  public componentDidUpdate(prevProps: IProps, prevState: IState) {\n    if (\n      !this.state.imageLoaded &&\n      !stringArraysEqual(prevProps.imgUrls, this.props.imgUrls)\n    ) {\n      this.setState({\n        imageLoaded: false,\n        imageLoadFailed: 0,\n      });\n      this.initCardImages(this.props);\n    }\n\n    // STUNNED\n    if (\n      !this.state.tokenImagesLoaded.stunned &&\n      !prevProps.cardState?.stunned &&\n      !!this.props.cardState?.stunned\n    ) {\n      this.stunnedImg.src =\n        process.env.PUBLIC_URL + \"/images/standard/stunned.png\";\n    }\n\n    // CONFUSED\n    if (\n      !this.state.tokenImagesLoaded.confused &&\n      !prevProps.cardState?.confused &&\n      !!this.props.cardState?.confused\n    ) {\n      this.confusedImg.src =\n        process.env.PUBLIC_URL + \"/images/standard/confused.png\";\n    }\n\n    // TOUGH\n    if (\n      !this.state.tokenImagesLoaded.tough &&\n      !prevProps.cardState?.tough &&\n      !!this.props.cardState?.tough\n    ) {\n      this.toughImg.src = process.env.PUBLIC_URL + \"/images/standard/tough.png\";\n    }\n  }\n\n  private initCardImages = (props: IProps) => {\n    this.imgs = props.imgUrls.map(() => new Image());\n\n    // When the image loads, set a flag in the state\n    this.imgs.forEach(\n      (img) =>\n        (img.onload = () => {\n          if (!this.unmounted) {\n            this.setState({\n              imageLoaded: true,\n            });\n          }\n        })\n    );\n\n    this.imgs.forEach(\n      (img) =>\n        (img.onerror = () => {\n          if (!this.unmounted) {\n            this.setState({\n              imageLoadFailed: this.state.imageLoadFailed + 1,\n            });\n          }\n        })\n    );\n\n    props.imgUrls.forEach((imgUrl, index) => (this.imgs[index].src = imgUrl));\n  };\n\n  public componentDidMount() {\n    this.unmounted = false;\n  }\n\n  public componentWillUnmount() {\n    this.unmounted = true;\n  }\n\n  public render() {\n    return this.renderCard(this.state.imageLoaded);\n  }\n\n  private renderCard(imageLoaded: boolean) {\n    const heightToUse = this.props.height || cardConstants.CARD_HEIGHT;\n    const widthToUse = this.props.width || cardConstants.CARD_WIDTH;\n\n    return this.renderUnanimatedCard(heightToUse, widthToUse, imageLoaded);\n  }\n\n  private renderUnanimatedCard = (\n    heightToUse: number,\n    widthToUse: number,\n    imageLoaded: boolean\n  ) => {\n    const imgToUse = imageLoaded\n      ? this.imgs.find((i) => i.complete && i.naturalHeight !== 0)\n      : undefined;\n\n    const scale = this.getScale(imgToUse, widthToUse, heightToUse);\n    const offset = {\n      x: widthToUse / 2,\n      y: heightToUse / 2,\n    };\n\n    const card = (\n      <Rect\n        key={`${this.props.id}-card`}\n        native={true}\n        rotation={this.props.exhausted ? 90 : 0}\n        cornerRadius={9}\n        x={this.props.x}\n        y={this.props.y}\n        width={widthToUse}\n        height={heightToUse}\n        offset={offset}\n        stroke={this.props.dropTarget ? \"blue\" : \"\"}\n        strokeWidth={this.props.dropTarget ? 2 : 0}\n        fillPatternRotation={\n          !imageLoaded ||\n          this.shouldRenderImageHorizontal(\n            this.props.typeCode || \"\",\n            HORIZONTAL_TYPE_CODES\n          )\n            ? 270\n            : 0\n        }\n        fillPatternImage={imgToUse}\n        fillPatternScaleX={scale.width}\n        fillPatternScaleY={scale.height}\n        fill={imageLoaded ? undefined : \"gray\"}\n        shadowColor={\n          !!this.props.controlledBy ? this.props.selectedColor : \"black\"\n        }\n        shadowBlur={this.props.dragging ? 20 : this.props.selected ? 10 : 0}\n        opacity={this.props.isGhost ? 0.5 : 1}\n        draggable={\n          this.props.controlledBy === \"\" ||\n          this.props.controlledBy === myPeerRef\n        }\n        onDragStart={this.handleDragStart}\n        onDragMove={this.handleDragMove}\n        onDragEnd={this.handleDragEnd}\n        onDblClick={this.handleDoubleClick}\n        onDblTap={this.handleDoubleClick}\n        onClick={this.handleClick}\n        onTap={this.handleClick}\n        onMouseDown={this.handleMouseDown}\n        onTouchStart={this.handleMouseDown}\n        onMouseOver={this.handleMouseOver}\n        onMouseOut={this.handleMouseOut}\n        onContextMenu={this.handleContextMenu}\n      />\n    );\n\n    const cardStackOffset = {\n      x: offset.x + 4,\n      y: offset.y - 4,\n    };\n\n    const cardStack =\n      (this.props.numCardsInStack || 1) > 1 ? (\n        <Rect\n          key={`${this.props.id}-cardStack`}\n          native={true}\n          rotation={this.props.exhausted ? 90 : 0}\n          cornerRadius={[9, 9, 9, 9]}\n          x={this.props.x}\n          y={this.props.y}\n          width={widthToUse}\n          height={heightToUse}\n          offset={cardStackOffset}\n          opacity={this.props.isGhost ? 0.5 : 1}\n          fill={\"gray\"}\n          shadowBlur={this.props.dragging ? 10 : this.props.selected ? 5 : 0}\n        />\n      ) : null;\n\n    const shouldRenderStunned =\n      !!this.props.cardState?.stunned && this.state.tokenImagesLoaded.stunned;\n\n    const stunnedToken = this.getTokenInSlot(\n      shouldRenderStunned,\n      this.stunnedImg,\n      offset,\n      0\n    );\n    const confusedToken = this.getTokenInSlot(\n      !!this.props.cardState?.confused && this.state.tokenImagesLoaded.confused,\n      this.confusedImg,\n      offset,\n      1\n    );\n    const toughToken = this.getTokenInSlot(\n      !!this.props.cardState?.tough && this.state.tokenImagesLoaded.tough,\n      this.toughImg,\n      offset,\n      2\n    );\n\n    const cardTokens =\n      this.props.dragging || this.props.isGhost ? null : (\n        <CardTokensContainer\n          key={`${this.props.id}-cardTokens`}\n          id={this.props.id}\n          x={this.props.x}\n          y={this.props.y}\n        ></CardTokensContainer>\n      );\n\n    const noImageCardNameText = this.renderCardName(\n      offset,\n      widthToUse,\n      heightToUse\n    );\n\n    return [\n      cardStack,\n      card,\n      noImageCardNameText,\n      stunnedToken,\n      confusedToken,\n      toughToken,\n      cardTokens,\n    ];\n  };\n\n  private renderCardName(\n    offset: Vector2d,\n    cardWidth: number,\n    cardHeight: number\n  ) {\n    const textOffset = { x: offset.x - 10, y: offset.y - 20 };\n    return this.state.imageLoadFailed === this.props.imgUrls.length ? (\n      <Text\n        key={`${this.props.id}-cardnametext`}\n        offset={textOffset}\n        x={this.props.x}\n        y={this.props.y}\n        width={cardWidth - 10}\n        height={cardHeight - 20}\n        fontSize={24}\n        text={this.props.name}\n        draggable={\n          this.props.controlledBy === \"\" ||\n          this.props.controlledBy === myPeerRef\n        }\n        onDragStart={this.handleDragStart}\n        onDragMove={this.handleDragMove}\n        onDragEnd={this.handleDragEnd}\n        onDblClick={this.handleDoubleClick}\n        onDblTap={this.handleDoubleClick}\n        onClick={this.handleClick}\n        onTap={this.handleClick}\n        onMouseDown={this.handleMouseDown}\n        onTouchStart={this.handleMouseDown}\n        onMouseOver={this.handleMouseOver}\n        onMouseOut={this.handleMouseOut}\n        onContextMenu={this.handleContextMenu}\n      ></Text>\n    ) : null;\n  }\n\n  private getTokenInSlot(\n    shouldRender: boolean,\n    img: HTMLImageElement,\n    offset: { x: number; y: number },\n    slot: 0 | 1 | 2\n  ) {\n    const dimensions = {\n      width: img.naturalWidth / 2,\n      height: img.naturalHeight / 2,\n    };\n\n    const stunnedOffset = {\n      x: offset.x - cardConstants.CARD_WIDTH + dimensions.width / 2,\n      y: offset.y - dimensions.height * slot - 5 * (slot + 1) - 10,\n    };\n\n    return shouldRender ? (\n      <Rect\n        key={`${this.props.id}-status${slot}`}\n        native={true}\n        cornerRadius={8}\n        x={this.props.x}\n        y={this.props.y}\n        width={dimensions.width}\n        height={dimensions.height}\n        fillPatternScaleX={0.5}\n        fillPatternScaleY={0.5}\n        offset={stunnedOffset}\n        fillPatternImage={img}\n      />\n    ) : null;\n  }\n\n  private shouldRenderImageHorizontal(\n    type: string,\n    typeCodes: string[]\n  ): boolean {\n    return typeCodes.includes(type) && !this.plainCardBack;\n  }\n\n  private get plainCardBack() {\n    return (\n      this.props.imgUrls.some((i) => i.includes(\"standard\")) &&\n      this.props.imgUrls.some((i) => i.includes(\"_back\"))\n    );\n  }\n\n  private getScale(\n    img: HTMLImageElement | undefined,\n    widthToUse: number,\n    heightToUse: number\n  ) {\n    const width = !!img ? widthToUse / img.naturalWidth : widthToUse;\n\n    const widthHorizontal = !!img ? heightToUse / img.naturalWidth : widthToUse;\n\n    const height = !!img ? heightToUse / img.naturalHeight : heightToUse;\n\n    const heightHorizontal = !!img\n      ? widthToUse / img.naturalHeight\n      : heightToUse;\n\n    return this.shouldRenderImageHorizontal(\n      this.props.typeCode || \"\",\n      HORIZONTAL_TYPE_CODES\n    )\n      ? { width: widthHorizontal, height: heightHorizontal }\n      : { width, height };\n  }\n\n  private handleContextMenu = (event: KonvaEventObject<PointerEvent>): void => {\n    if (!!this.props.handleContextMenu) {\n      this.props.handleContextMenu(this.props.id, event);\n    }\n  };\n\n  private handleDoubleClick = (event: KonvaEventObject<MouseEvent>) => {\n    if (this.props.handleDoubleClick) {\n      this.props.handleDoubleClick(this.props.id, event);\n    }\n  };\n\n  private handleDragStart = (event: KonvaEventObject<DragEvent>) => {\n    if (this.props.handleDragStart) {\n      this.props.handleDragStart(this.props.id, event);\n    }\n  };\n\n  private handleDragMove = (event: any) => {\n    if (this.props.handleDragMove) {\n      this.props.handleDragMove({\n        id: this.props.id,\n        dx: event.target.x() - this.props.x,\n        dy: event.target.y() - this.props.y,\n      });\n    }\n  };\n\n  private handleDragEnd = () => {\n    if (this.props.handleDragEnd && this.props.dragging) {\n      this.props.handleDragEnd(this.props.id);\n    }\n  };\n\n  private handleClick = (event: KonvaEventObject<MouseEvent>) => {\n    if (this.props.handleClick) {\n      this.props.handleClick(this.props.id, event);\n      event.cancelBubble = true;\n    }\n  };\n\n  private handleMouseDown = (event: any) => {\n    event.cancelBubble = true;\n  };\n\n  private handleMouseOver = () => {\n    if (this.props.handleHover) {\n      this.props.handleHover(this.props.id);\n    }\n  };\n\n  private handleMouseOut = () => {\n    if (this.props.handleHoverLeave) {\n      this.props.handleHoverLeave(this.props.id);\n    }\n  };\n}\n\nexport default Card;\n","import { Vector2d } from \"konva/types/types\";\nimport * as React from \"react\";\nimport { Component } from \"react\";\nimport Menu from \"@material-ui/core/Menu\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\n\nexport interface ContextMenuItem {\n  label: string;\n  action: () => void;\n}\n\ninterface IProps {\n  position: Vector2d;\n  items: ContextMenuItem[];\n  contextItemClicked?: (item: ContextMenuItem) => void;\n  hideContextMenu: () => void;\n}\n\nclass ContextMenu extends Component<IProps> {\n  render() {\n    return (\n      <div\n        id=\"context-menu-layer\"\n        onContextMenu={this.preventDefault}\n        onClick={this.props.hideContextMenu}\n      >\n        <Menu\n          keepMounted\n          open={true}\n          onClose={this.props.hideContextMenu}\n          anchorReference=\"anchorPosition\"\n          anchorPosition={{\n            top: this.props.position.y + 8,\n            left: this.props.position.x + 8,\n          }}\n        >\n          {this.props.items.map((i, index) => (\n            <MenuItem\n              key={`contextMenu-item-${index}`}\n              onClick={this.handleContextItemClicked(i)}\n            >\n              {i.label}\n            </MenuItem>\n          ))}\n        </Menu>\n      </div>\n    );\n  }\n\n  private preventDefault = (\n    event: React.MouseEvent<HTMLElement, MouseEvent>\n  ) => {\n    event.preventDefault();\n  };\n\n  private handleContextItemClicked = (item: ContextMenuItem) => () => {\n    item.action();\n    if (!!this.props.contextItemClicked) {\n      this.props.contextItemClicked(this.props.items[0]);\n    }\n    this.props.hideContextMenu();\n  };\n}\n\nexport default ContextMenu;\n","import { Component } from \"react\";\nimport * as React from \"react\";\n\ninterface IProps {\n  loadDeckId: (id: number) => void;\n}\n\nclass DeckLoader extends Component<IProps> {\n  render() {\n    return (\n      <input\n        onKeyDown={this.handleKeyDown}\n        onClick={this.cancelBubble}\n        type=\"number\"\n      ></input>\n    );\n  }\n\n  private cancelBubble = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {\n    event.stopPropagation();\n  };\n\n  private handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {\n    if (event.key === \"Enter\") {\n      this.props.loadDeckId(+event.currentTarget.value);\n    }\n  };\n}\n\nexport default DeckLoader;\n","import { Component } from \"react\";\nimport * as React from \"react\";\nimport { IEncounterEntity } from \"./features/cards-data/cards-data.selectors\";\nimport Autocomplete from \"@material-ui/lab/Autocomplete\";\nimport TextField from \"@material-ui/core/TextField\";\ninterface IProps {\n  encounterData: IEncounterEntity[];\n  loadCards: (cards: string[]) => void;\n}\n\nclass EncounterLoader extends Component<IProps> {\n  render() {\n    return (\n      <div onClick={this.cancelBubble}>\n        <Autocomplete\n          id=\"encounter-loader-combobox\"\n          options={this.props.encounterData || []}\n          getOptionLabel={(option) => option.setData.name}\n          style={{ width: 300 }}\n          onChange={this.handleSelected}\n          renderInput={(params) => (\n            <TextField {...params} label=\"Encounter Set\" variant=\"outlined\" />\n          )}\n        />\n      </div>\n    );\n  }\n\n  private handleSelected = (_event: any, value: IEncounterEntity | null) => {\n    if (!!value) {\n      this.props.loadCards(value.cards.map((c) => c.code));\n    }\n  };\n\n  private cancelBubble = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {\n    event.stopPropagation();\n  };\n}\n\nexport default EncounterLoader;\n","import { createSelector } from \"@reduxjs/toolkit\";\nimport { CardData } from \"../../external-api/marvel-card-data\";\nimport { RootState } from \"../../store/rootReducer\";\nimport { Set } from \"../cards-data/initialState\";\n\nexport interface IEncounterEntity {\n  setCode: string;\n  setData: Set;\n  cards: CardData[];\n}\n\nexport const getCardsData = (state: RootState) => state.cardsData;\n\nexport const getCardsDataEntities = createSelector(\n  getCardsData,\n  (cardsData) => {\n    return { ...cardsData.entities, ...cardsData.encounterEntities };\n  }\n);\n\nexport const getCardsDataHeroEntities = createSelector(\n  getCardsData,\n  (cardsData) => {\n    return cardsData.entities;\n  }\n);\n\nexport const getCardsDataEncounterEntities = createSelector(\n  getCardsData,\n  (cardsData) => {\n    return cardsData.encounterEntities;\n  }\n);\n\nexport const getCardsDataSetData = createSelector(getCardsData, (cardsData) => {\n  return cardsData.setData;\n});\n\nexport const getCardsDataEncounterEntitiesBySetCode = createSelector(\n  getCardsDataEncounterEntities,\n  getCardsDataSetData,\n  (encounterEntities, setData): IEncounterEntity[] => {\n    const setTypesEncounters: { [key: string]: CardData[] } = {};\n\n    Object.values(encounterEntities).forEach((encounterCard) => {\n      const setCode = encounterCard.set_code || \"unknown\";\n      if (!!setTypesEncounters[setCode]) {\n        setTypesEncounters[setCode].push(encounterCard);\n      } else {\n        setTypesEncounters[setCode] = [encounterCard];\n      }\n    });\n\n    return Object.entries(setTypesEncounters)\n      .map(([key, value]) => ({\n        setCode: key,\n        setData: setData[key],\n        cards: value,\n      }))\n      .filter(\n        (set) =>\n          set.setData.setTypeCode !== \"nemesis\" &&\n          set.setData.setTypeCode !== \"hero\"\n      )\n      .sort((a, b) => (a.setData.name > b.setData.name ? 1 : -1));\n  }\n);\n","import { connect } from \"react-redux\";\nimport EncounterLoader from \"./EncounterLoader\";\nimport { getCardsDataEncounterEntitiesBySetCode } from \"./features/cards-data/cards-data.selectors\";\n\nimport { RootState } from \"./store/rootReducer\";\n\nconst mapStateToProps = (state: RootState) => {\n  return {\n    encounterData: getCardsDataEncounterEntitiesBySetCode(state),\n  };\n};\n\nconst EncounterLoaderContainer = connect(mapStateToProps, {})(EncounterLoader);\n\nexport default EncounterLoaderContainer;\n","import { Vector2d } from \"konva/types/types\";\n\nexport const getDistance = (point1: Vector2d, point2: Vector2d): number => {\n  const deltaX = point1.x - point2.x;\n  const deltaY = point1.y - point2.y;\n  return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n};\n","import { RootState } from \"./rootReducer\";\n\nexport const loadState = (key: string) => {\n  try {\n    const serializedState = localStorage.getItem(key);\n    if (serializedState === null) {\n      return {};\n    }\n    const baseState = JSON.parse(serializedState || \"{}\");\n\n    return baseState.present ?? baseState;\n  } catch (err) {\n    console.error(\"problem parsing\");\n    return {};\n  }\n};\n\nexport const saveState = (state: RootState) => {\n  const blacklistStateKeys = [\"cardsData\"];\n  try {\n    Object.entries(state).forEach(([key, value]) => {\n      if (!blacklistStateKeys.includes(key)) {\n        const serializedState = JSON.stringify(value);\n        localStorage.setItem(key, serializedState);\n      }\n    });\n  } catch {\n    // ignore write errors\n    console.error(\"Error writing state to local storage\");\n  }\n};\n","import { loadState } from \"../../store/localStorage\";\nimport { CounterTokenType, StatusTokenType } from \"./cards.slice\";\n\nexport interface ICardStack {\n  controlledBy: string;\n  dragging: boolean;\n  exhausted: boolean;\n  faceup: boolean;\n  fill: string;\n  id: string;\n  selected: boolean;\n  x: number;\n  y: number;\n  cardStack: ICardDetails[];\n  statusTokens: {\n    [K in StatusTokenType]: boolean;\n  };\n  counterTokens: {\n    [K in CounterTokenType]: number;\n  };\n}\n\nexport interface ICardDetails {\n  jsonId: string;\n}\n\nexport interface IPreviewCard {\n  id: string;\n}\n\nexport interface ICardsState {\n  cards: ICardStack[];\n  ghostCards: ICardStack[];\n  previewCard: IPreviewCard | null;\n  dropTargetCard: ICardStack | null;\n  panMode: boolean;\n}\n\nconst localStorageState: ICardsState = loadState(\"cards\");\n\n// Make sure initially, none of the cards are \"owned\" / \"selected\"\nif (!!localStorageState.cards) {\n  localStorageState.cards.forEach((c) => {\n    c.controlledBy = \"\";\n    c.selected = false;\n  });\n}\n\nconst defaultState: ICardsState = {\n  cards: [],\n  ghostCards: [],\n  previewCard: null,\n  dropTargetCard: null,\n  panMode: true,\n};\n\nexport const initialState: ICardsState = {\n  ...defaultState,\n  ...localStorageState,\n};\n","import { createSlice, PayloadAction, CaseReducer } from \"@reduxjs/toolkit\";\nimport { getDistance } from \"../../utilities/geo\";\nimport {\n  initialState,\n  ICardsState,\n  ICardStack,\n  ICardDetails,\n} from \"./initialState\";\nimport { fetchDecklistById } from \"./cards.thunks\";\nimport { cardConstants } from \"../../constants/card-constants\";\nimport { receiveRemoteGameState, resetApp } from \"../../store/global.actions\";\nimport {\n  addCardStackWithId,\n  pullCardOutOfCardStackWithId,\n  replaceCardStack,\n  startCardMoveWithSplitStackId,\n} from \"./cards.actions\";\n\nconst CARD_DROP_TARGET_DISTANCE = 30;\n\nexport enum StatusTokenType {\n  Stunned = \"stunned\",\n  Confused = \"confused\",\n  Tough = \"tough\",\n}\n\nexport enum CounterTokenType {\n  Damage = \"damage\",\n  Threat = \"threat\",\n  Generic = \"generic\",\n}\n\n// Helper methods\nconst getCardStackWithId = (\n  state: ICardsState,\n  id: string\n): ICardStack | undefined => {\n  return state.cards.find((card) => card.id === id);\n};\n\nconst mutateCardWithId = (\n  state: ICardsState,\n  id: string,\n  ref: string,\n  callback: (card: ICardStack) => void\n) => {\n  const cardToUpdate = getCardStackWithId(state, id);\n  if (\n    cardToUpdate &&\n    (cardToUpdate.controlledBy === \"\" || cardToUpdate.controlledBy === ref)\n  ) {\n    callback(cardToUpdate);\n  }\n};\n\nconst foreachSelectedAndControlledCard = (\n  state: ICardsState,\n  actorRef: string,\n  callback: (card: ICardStack) => void\n) => {\n  state.cards\n    .filter((card) => card.selected && card.controlledBy === actorRef)\n    .forEach((card) => callback(card));\n};\n\nconst foreachUnselectedCard = (\n  state: ICardsState,\n  callback: (card: ICardStack) => void\n) => {\n  state.cards\n    .filter((card) => !card.selected)\n    .forEach((card) => callback(card));\n};\n\n// Reducers\nconst selectCardReducer: CaseReducer<\n  ICardsState,\n  PayloadAction<{ id: string; unselectOtherCards: boolean }>\n> = (state, action) => {\n  if (action.payload.unselectOtherCards) {\n    unselectAllCardsReducer(state, action);\n  }\n\n  mutateCardWithId(\n    state,\n    action.payload.id,\n    (action as any).ACTOR_REF,\n    (card) => {\n      card.selected = true;\n      card.controlledBy = (action as any).ACTOR_REF;\n    }\n  );\n};\n\nconst unselectCardReducer: CaseReducer<ICardsState, PayloadAction<string>> = (\n  state,\n  action\n) => {\n  mutateCardWithId(state, action.payload, (action as any).ACTOR_REF, (card) => {\n    card.selected = false;\n    card.controlledBy = \"\";\n  });\n};\n\nconst toggleSelectCardReducer: CaseReducer<\n  ICardsState,\n  PayloadAction<string>\n> = (state, action) => {\n  mutateCardWithId(state, action.payload, (action as any).ACTOR_REF, (card) => {\n    card.selected = !card.selected;\n    if (!card.selected) {\n      card.controlledBy = \"\";\n    } else {\n      card.controlledBy = (action as any).ACTOR_REF;\n    }\n  });\n};\n\nconst exhaustCardReducer: CaseReducer<ICardsState, PayloadAction<string>> = (\n  state,\n  action\n) => {\n  state.cards\n    .filter(\n      (card) =>\n        card.controlledBy === (action as any).ACTOR_REF &&\n        (card.id === action.payload || card.selected)\n    )\n    .forEach((card) => {\n      card.exhausted = !card.exhausted;\n    });\n};\n\nconst cardMoveReducer: CaseReducer<\n  ICardsState,\n  PayloadAction<{ id: string; dx: number; dy: number }>\n> = (state, action) => {\n  const movedCards: ICardStack[] = [];\n\n  let primaryCard: ICardStack;\n\n  state.cards\n    .filter(\n      (card) =>\n        card.id === action.payload.id ||\n        (card.selected && card.controlledBy === (action as any).ACTOR_REF)\n    )\n    .forEach((card) => {\n      if (card.id === action.payload.id) {\n        primaryCard = card;\n      }\n\n      card.x += action.payload.dx;\n      card.y += action.payload.dy;\n\n      movedCards.push(card);\n    });\n\n  // go through and find if any unselected cards are potential drop targets\n  // If so, get the closest one\n  const possibleDropTargets: { distance: number; card: ICardStack }[] = [];\n  foreachUnselectedCard(state, (card) => {\n    const distance = getDistance(card, primaryCard);\n    if (distance < CARD_DROP_TARGET_DISTANCE) {\n      possibleDropTargets.push({\n        distance,\n        card,\n      });\n    }\n  });\n\n  state.dropTargetCard =\n    possibleDropTargets.sort((c1, c2) => c1.distance - c2.distance)[0]?.card ??\n    null;\n\n  // put the moved cards at the end. TODO: we could just store the move order or move time\n  // or something, and the array could be a selector\n  movedCards.forEach((movedCard) => {\n    state.cards.push(state.cards.splice(state.cards.indexOf(movedCard), 1)[0]);\n  });\n};\n\nconst endCardMoveReducer: CaseReducer<ICardsState, PayloadAction<string>> = (\n  state,\n  action\n) => {\n  let dropTargetCards: ICardDetails[] = [];\n  state.cards\n    .filter((card) => card.id === action.payload || card.selected)\n    .forEach((card) => {\n      card.dragging = false;\n\n      if (!!state.dropTargetCard) {\n        // Add the cards to the drop Target card stack\n        dropTargetCards = dropTargetCards.concat(card.cardStack);\n      }\n    });\n\n  // Now, if there was a drop target card, remove all those cards from the state\n  if (!!state.dropTargetCard) {\n    state.cards = state.cards.filter(\n      (card) => !(card.id === action.payload || card.selected)\n    );\n\n    const dropTargetCard = state.cards.find(\n      (card) => card.id === state.dropTargetCard?.id\n    );\n    if (!!dropTargetCard && dropTargetCards.length > 0) {\n      // add the cards we've collected to the top of the stack\n      dropTargetCard.cardStack = dropTargetCards.concat(\n        dropTargetCard.cardStack\n      );\n    }\n  }\n\n  state.ghostCards = [];\n  state.dropTargetCard = null;\n};\n\nconst selectMultipleCardsReducer: CaseReducer<\n  ICardsState,\n  PayloadAction<{ ids: string[] }>\n> = (state, action) => {\n  action.payload.ids\n    .map((id) => state.cards.find((card) => card.id === id))\n    .forEach((card) => {\n      if (\n        card &&\n        (card.controlledBy === \"\" ||\n          card.controlledBy === (action as any).ACTOR_REF)\n      ) {\n        card.selected = true;\n        card.controlledBy = (action as any).ACTOR_REF;\n      }\n    });\n};\n\nconst unselectAllCardsReducer: CaseReducer<ICardsState, PayloadAction<any>> = (\n  state,\n  action\n) => {\n  state.cards\n    .filter(\n      (card) =>\n        card.controlledBy === \"\" ||\n        card.controlledBy === (action as any).ACTOR_REF\n    )\n    .forEach((card) => {\n      card.selected = false;\n      card.controlledBy = \"\";\n    });\n};\n\nconst hoverCardReducer: CaseReducer<ICardsState, PayloadAction<string>> = (\n  state,\n  action\n) => {\n  const cardToPreview = state.cards.find((c) => c.id === action.payload);\n  if (!cardToPreview?.faceup) return;\n\n  if (state.previewCard === null) {\n    state.previewCard = {\n      id: action.payload,\n    };\n  } else if (action.payload !== state.previewCard.id) {\n    state.previewCard.id = action.payload;\n  }\n};\n\nconst hoverLeaveCardReducer: CaseReducer<ICardsState> = (state) => {\n  if (state.previewCard !== null) {\n    state.previewCard = null;\n  }\n};\n\nconst togglePanModeReducer: CaseReducer<ICardsState> = (state) => {\n  state.panMode = !state.panMode;\n};\n\nconst flipCardsReducer: CaseReducer<ICardsState> = (state, action) => {\n  state.cards\n    .filter((card) => card.selected)\n    .forEach((card) => {\n      card.faceup = !card.faceup;\n      card.cardStack = card.cardStack.reverse();\n    });\n};\n\nconst resetCardsReducer: CaseReducer<ICardsState> = (state) => {\n  state.cards = [];\n};\n\nconst toggleTokenReducer: CaseReducer<\n  ICardsState,\n  PayloadAction<{ id: string; tokenType: StatusTokenType; value: boolean }>\n> = (state, action) => {\n  const cardToToggle = state.cards.find((c) => c.id === action.payload.id);\n  if (!!cardToToggle) {\n    cardToToggle.statusTokens[action.payload.tokenType] = action.payload.value;\n  }\n};\n\nconst adjustCounterTokenReducer: CaseReducer<\n  ICardsState,\n  PayloadAction<{ id: string; tokenType: CounterTokenType; delta: number }>\n> = (state, action) => {\n  const cardToToggle = state.cards.find((c) => c.id === action.payload.id);\n  if (!!cardToToggle) {\n    cardToToggle.counterTokens[action.payload.tokenType] +=\n      action.payload.delta;\n    if (cardToToggle.counterTokens[action.payload.tokenType] < 0) {\n      cardToToggle.counterTokens[action.payload.tokenType] = 0;\n    }\n  }\n};\n// Selectors\n\n// slice\nconst cardsSlice = createSlice({\n  name: \"cards\",\n  initialState: initialState,\n  reducers: {\n    selectCard: selectCardReducer,\n    unselectCard: unselectCardReducer,\n    toggleSelectCard: toggleSelectCardReducer,\n    exhaustCard: exhaustCardReducer,\n    cardMove: cardMoveReducer,\n    endCardMove: endCardMoveReducer,\n    selectMultipleCards: selectMultipleCardsReducer,\n    unselectAllCards: unselectAllCardsReducer,\n    hoverCard: hoverCardReducer,\n    hoverLeaveCard: hoverLeaveCardReducer,\n    togglePanMode: togglePanModeReducer,\n    flipCards: flipCardsReducer,\n    resetCards: resetCardsReducer,\n    toggleToken: toggleTokenReducer,\n    adjustCounterToken: adjustCounterTokenReducer,\n  },\n  extraReducers: (builder) => {\n    builder.addCase(receiveRemoteGameState, (state, action) => {\n      // TODO: find a way to keep this automatic\n      state.cards = action.payload.cards.present.cards;\n      state.ghostCards = action.payload.cards.present.ghostCards;\n    });\n\n    builder.addCase(replaceCardStack, (state, action) => {\n      const cardToReplaceStack = state.cards.find(\n        (c) => c.id === action.payload.id\n      );\n      if (!!cardToReplaceStack) {\n        cardToReplaceStack.cardStack = action.payload.newStack;\n      }\n    });\n\n    builder.addCase(resetApp, (state) => {\n      state.cards = [];\n      state.previewCard = null;\n      state.dropTargetCard = null;\n      state.ghostCards = [];\n      state.panMode = true;\n    });\n\n    builder.addCase(addCardStackWithId, (state, action) => {\n      const newStack: ICardStack = {\n        controlledBy: \"\",\n        x: action.payload.position.x,\n        y: action.payload.position.y,\n        dragging: false,\n        exhausted: false,\n        faceup: true,\n        fill: \"red\",\n        id: action.payload.id,\n        cardStack: action.payload.cardJsonIds.map((jsonId) => ({\n          jsonId,\n        })),\n        selected: false,\n        statusTokens: {\n          stunned: false,\n          confused: false,\n          tough: false,\n        },\n        counterTokens: {\n          damage: 0,\n          threat: 0,\n          generic: 0,\n        },\n      };\n\n      state.cards.push(newStack);\n    });\n\n    builder.addCase(pullCardOutOfCardStackWithId, (state, action) => {\n      const cardStackToUse = state.cards.find(\n        (c) => c.id === action.payload.cardStackId\n      );\n      if (!!cardStackToUse && cardStackToUse.cardStack.length > 1) {\n        const newCardStack: ICardDetails[] = [\n          { jsonId: action.payload.jsonId },\n        ];\n        const newCard = Object.assign({}, cardStackToUse, {\n          cardStack: newCardStack,\n        });\n        newCard.id = action.payload.id;\n        newCard.selected = true;\n        newCard.controlledBy = (action as any).ACTOR_REF;\n        newCard.x = newCard.x + cardConstants.CARD_WIDTH + 5;\n\n        cardStackToUse.cardStack = cardStackToUse.cardStack.filter(\n          (c) => c.jsonId !== action.payload.jsonId\n        );\n        cardStackToUse.selected = false;\n        cardStackToUse.controlledBy = \"\";\n\n        state.cards.push(newCard);\n      }\n    });\n\n    builder.addCase(startCardMoveWithSplitStackId, (state, action) => {\n      // first, if the card moving isn't currently selected, clear all _our_ selected cards\n      const cardToStartMoving = getCardStackWithId(state, action.payload.id);\n      if (cardToStartMoving && !cardToStartMoving.selected) {\n        state.cards = state.cards.map((card) => {\n          if (\n            card.controlledBy === \"\" ||\n            card.controlledBy === (action as any).ACTOR_REF\n          ) {\n            card.selected = card.id === action.payload.id;\n            if (card.selected) {\n              card.controlledBy = (action as any).ACTOR_REF;\n            } else {\n              card.controlledBy = \"\";\n            }\n          }\n          return card;\n        });\n      }\n\n      // If we are splitting, make a new stack of cards\n      if (action.payload.splitTopCard) {\n        const cardToMove = state.cards.find((c) => c.id === action.payload.id);\n\n        if (!cardToMove) {\n          throw new Error(\"Expected to find card\");\n        }\n\n        cardToMove.selected = false;\n        cardToMove.controlledBy = \"\";\n\n        const topCard = cardToMove.cardStack.shift();\n        const newCard = Object.assign({}, cardToMove, {\n          selected: true,\n          controlledBy: (action as any).ACTOR_REF,\n          dragging: true,\n          cardStack: [topCard],\n        });\n\n        cardToMove.id = action.payload.splitCardId;\n\n        state.cards.push(newCard);\n      }\n\n      // Now all selected cards should be put into ghost cards, unless we are splitting the top card\n      state.ghostCards = [];\n\n      if (!action.payload.splitTopCard) {\n        foreachSelectedAndControlledCard(\n          state,\n          (action as any).ACTOR_REF,\n          (card) => {\n            card.dragging = true;\n            state.ghostCards.push(Object.assign({}, card));\n          }\n        );\n      }\n\n      //Finally, if we have a preview card, clear it\n      state.previewCard = null;\n    });\n\n    builder.addCase(fetchDecklistById.fulfilled, (state, action) => {\n      console.log(\"got decklist\");\n      console.log(action);\n\n      const heroCard: ICardStack = {\n        controlledBy: \"\",\n        x: action.payload.position.x,\n        y: action.payload.position.y,\n        dragging: false,\n        exhausted: false,\n        faceup: true,\n        fill: \"red\",\n        id: action.payload.heroId,\n        cardStack: [{ jsonId: action.payload.data.investigator_code }],\n        selected: false,\n        statusTokens: {\n          stunned: false,\n          confused: false,\n          tough: false,\n        },\n        counterTokens: {\n          damage: 0,\n          threat: 0,\n          generic: 0,\n        },\n      };\n\n      let mainDeckStack: ICardDetails[] = [];\n      Object.entries(action.payload.data.slots).forEach(([key, value]) => {\n        const cardDetails: ICardDetails[] = Array.from(Array(value).keys()).map(\n          (): ICardDetails => ({ jsonId: key })\n        );\n        mainDeckStack = mainDeckStack.concat(cardDetails);\n      });\n\n      const cardPadding = cardConstants.CARD_WIDTH + 10;\n\n      const newDeck: ICardStack = {\n        controlledBy: \"\",\n        x: action.payload.position.x + cardPadding,\n        y: action.payload.position.y,\n        dragging: false,\n        exhausted: false,\n        faceup: true,\n        fill: \"red\",\n        id: action.payload.dataId,\n        cardStack: mainDeckStack,\n        selected: false,\n        statusTokens: {\n          stunned: false,\n          confused: false,\n          tough: false,\n        },\n        counterTokens: {\n          damage: 0,\n          threat: 0,\n          generic: 0,\n        },\n      };\n\n      const encounterDeck: ICardStack = {\n        controlledBy: \"\",\n        x: action.payload.position.x + cardPadding * 2,\n        y: action.payload.position.y,\n        dragging: false,\n        exhausted: false,\n        faceup: true,\n        fill: \"red\",\n        id: action.payload.encounterDeckId,\n        cardStack: action.payload.relatedEncounterDeck.map((jsonId) => ({\n          jsonId,\n        })),\n        selected: false,\n        statusTokens: {\n          stunned: false,\n          confused: false,\n          tough: false,\n        },\n        counterTokens: {\n          damage: 0,\n          threat: 0,\n          generic: 0,\n        },\n      };\n\n      const obligationDeck: ICardStack = {\n        controlledBy: \"\",\n        x: action.payload.position.x + cardPadding * 3,\n        y: action.payload.position.y,\n        dragging: false,\n        exhausted: false,\n        faceup: true,\n        fill: \"red\",\n        id: action.payload.obligationDeckId,\n        cardStack: action.payload.relatedObligationDeck.map((jsonId) => ({\n          jsonId,\n        })),\n        selected: false,\n        statusTokens: {\n          stunned: false,\n          confused: false,\n          tough: false,\n        },\n        counterTokens: {\n          damage: 0,\n          threat: 0,\n          generic: 0,\n        },\n      };\n\n      state.cards.push(heroCard, newDeck, encounterDeck, obligationDeck);\n    });\n  },\n});\n\nexport const {\n  selectCard,\n  unselectCard,\n  toggleSelectCard,\n  exhaustCard,\n  cardMove,\n  endCardMove,\n  selectMultipleCards,\n  unselectAllCards,\n  hoverCard,\n  hoverLeaveCard,\n  togglePanMode,\n  flipCards,\n  resetCards,\n  toggleToken,\n  adjustCounterToken,\n} = cardsSlice.actions;\n\nexport default cardsSlice.reducer;\n","import { createAction } from \"@reduxjs/toolkit\";\nimport { Vector2d } from \"konva/types/types\";\nimport { ICardDetails } from \"./initialState\";\n\nexport interface AddCardStackWithIdPayload {\n  cardJsonIds: string[];\n  position: Vector2d;\n  id: string;\n}\n\nexport interface PullCardOutOfCardStackWithIdPayload {\n  cardStackId: string;\n  jsonId: string;\n  pos: Vector2d;\n  id: string;\n}\n\nexport interface StartCardMoveWithSplitStackIdPayload {\n  id: string;\n  splitTopCard: boolean;\n  splitCardId: string;\n}\n\nexport interface ReplaceCardStackPayload {\n  id: string;\n  newStack: ICardDetails[];\n}\n\nexport const addCardStackWithId = createAction<AddCardStackWithIdPayload>(\n  \"addCardStackWithId\"\n);\n\nexport const pullCardOutOfCardStackWithId = createAction<PullCardOutOfCardStackWithIdPayload>(\n  \"pullCardOutOfCardStackWithId\"\n);\n\nexport const startCardMoveWithSplitStackId = createAction<StartCardMoveWithSplitStackIdPayload>(\n  \"startCardMoveWithSplitStackId\"\n);\n\nexport const replaceCardStack = createAction<ReplaceCardStackPayload>(\n  \"replaceCardStack\"\n);\n","import { Action, createAsyncThunk, ThunkAction } from \"@reduxjs/toolkit\";\nimport axios from \"axios\";\nimport { Vector2d } from \"konva/types/types\";\nimport { RootState } from \"../../store/rootReducer\";\nimport {\n  getCardsDataEncounterEntities,\n  getCardsDataHeroEntities,\n} from \"../cards-data/cards-data.selectors\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport {\n  addCardStackWithId,\n  pullCardOutOfCardStackWithId,\n  replaceCardStack,\n  startCardMoveWithSplitStackId,\n} from \"./cards.actions\";\nimport { ICardDetails } from \"./initialState\";\nimport { getCards } from \"./cards.selectors\";\n\ninterface AddCardStackPayload {\n  cardJsonIds: string[];\n  position: Vector2d;\n}\n\nexport interface PullCardOutOfCardStackPayload {\n  cardStackId: string;\n  jsonId: string;\n  pos: Vector2d;\n}\n\nexport interface StartCardMovePayload {\n  id: string;\n  splitTopCard: boolean;\n}\n\nexport const shuffleStack = (\n  id: string\n): ThunkAction<void, RootState, unknown, Action<string>> => (\n  dispatch,\n  getState\n) => {\n  const cardsState = getCards(getState());\n  const stackToShuffle = cardsState.cards.find((c) => c.id === id);\n  if (!!stackToShuffle) {\n    const shuffledStack = shuffle(stackToShuffle.cardStack);\n    dispatch(replaceCardStack({ id, newStack: shuffledStack }));\n  }\n};\n\nexport const addCardStack = (\n  payload: AddCardStackPayload\n): ThunkAction<void, RootState, unknown, Action<string>> => (dispatch) => {\n  const payloadWithId = {\n    ...payload,\n    id: uuidv4(),\n  };\n  dispatch(addCardStackWithId(payloadWithId));\n};\n\nexport const pullCardOutOfCardStack = (\n  payload: PullCardOutOfCardStackPayload\n): ThunkAction<void, RootState, unknown, Action<string>> => (dispatch) => {\n  const payloadWithId = {\n    ...payload,\n    id: uuidv4(),\n  };\n  dispatch(pullCardOutOfCardStackWithId(payloadWithId));\n};\n\nexport const startCardMove = (\n  payload: StartCardMovePayload\n): ThunkAction<void, RootState, unknown, Action<string>> => (dispatch) => {\n  const payloadWithId = {\n    ...payload,\n    splitCardId: uuidv4(),\n  };\n  dispatch(startCardMoveWithSplitStackId(payloadWithId));\n};\n\nexport const fetchDecklistById = createAsyncThunk(\n  \"decklist/fetchByIdStatus\",\n  async (payload: { decklistId: number; position: Vector2d }, thunkApi) => {\n    const response = await axios.get(\n      `https://marvelcdb.com/api/public/decklist/${payload.decklistId}`\n    );\n    const state: RootState = thunkApi.getState() as RootState;\n    const heroCardsData = getCardsDataHeroEntities(state);\n    const heroSetCode = heroCardsData[response.data.investigator_code].set_code;\n    const encounterCardsData = getCardsDataEncounterEntities(state);\n\n    const heroObligationDeck = Object.entries(encounterCardsData)\n      .filter(\n        ([_key, value]) =>\n          value.set_code === `${heroSetCode}` &&\n          value.type_code === \"obligation\"\n      )\n      .map(([key, _value]) => key);\n\n    const heroEncounterDeck = Object.entries(encounterCardsData)\n      .filter(([_key, value]) => value.set_code === `${heroSetCode}_nemesis`)\n      .map(([key, _value]) => key);\n    // get the encounter cards for this deck\n    return {\n      position: payload.position,\n      heroId: uuidv4(),\n      data: response.data,\n      dataId: uuidv4(),\n      relatedEncounterDeck: heroEncounterDeck,\n      encounterDeckId: uuidv4(),\n      relatedObligationDeck: heroObligationDeck,\n      obligationDeckId: uuidv4(),\n    };\n  }\n);\n\nconst shuffle = (array: ICardDetails[]): ICardDetails[] => {\n  const returnArray = JSON.parse(JSON.stringify(array));\n  var currentIndex = returnArray.length,\n    temporaryValue,\n    randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = returnArray[currentIndex];\n    returnArray[currentIndex] = returnArray[randomIndex];\n    returnArray[randomIndex] = temporaryValue;\n  }\n\n  return returnArray;\n};\n","import { createAction } from \"@reduxjs/toolkit\";\nimport { RootState } from \"./rootReducer\";\n\nexport const resetApp = createAction(\"resetAction\");\n\nexport const receiveRemoteGameState = createAction<RootState>(\n  \"receiveRemoteGameState\"\n);\n","import { Vector2d } from \"konva/types/types\";\nimport * as React from \"react\";\nimport { Component } from \"react\";\nimport \"./TopLayer.scss\";\n\ninterface IProps {\n  position: Vector2d;\n  completed: () => void;\n}\n\nclass TopLayer extends Component<IProps> {\n  render() {\n    const containerStyle: React.CSSProperties = {\n      top: `${this.props.position.y + 8}px`,\n      left: `${this.props.position.x + 8}px`,\n    };\n    return (\n      <div\n        id=\"top-layer\"\n        onClick={this.props.completed}\n        onContextMenu={this.preventDefault}\n      >\n        <div\n          className=\"top-layer-content-wrapper\"\n          style={containerStyle}\n          onContextMenu={this.preventDefault}\n          onClick={this.handleClick}\n        >\n          {this.props.children}\n        </div>\n      </div>\n    );\n  }\n\n  private handleClick = (event: React.MouseEvent<HTMLElement>) => {\n    event.stopPropagation();\n    this.props.completed();\n  };\n\n  private preventDefault = (\n    event: React.MouseEvent<HTMLElement, MouseEvent>\n  ) => {\n    event.preventDefault();\n  };\n}\n\nexport default TopLayer;\n","import { Component } from \"react\";\nimport * as React from \"react\";\nimport Autocomplete from \"@material-ui/lab/Autocomplete\";\nimport TextField from \"@material-ui/core/TextField\";\nimport { CardData } from \"./external-api/marvel-card-data\";\nimport { ICardData } from \"./features/cards-data/initialState\";\nimport { ICardStack } from \"./features/cards/initialState\";\ninterface IProps {\n  cardsDataEntities: ICardData;\n  card: ICardStack;\n  cardSelected: (jsonId: string) => void;\n}\n\nclass CardStackCardSelector extends Component<IProps> {\n  private cardsDataInStack: CardData[] = [];\n\n  constructor(props: IProps) {\n    super(props);\n    this.cardsDataInStack = props.card.cardStack.map((c) => {\n      return this.props.cardsDataEntities[c.jsonId];\n    });\n  }\n\n  render() {\n    return (\n      <div onClick={this.cancelBubble}>\n        <Autocomplete\n          id=\"cardstack-card-selector-combobox\"\n          options={this.cardsDataInStack}\n          getOptionLabel={(option) => option.name}\n          style={{ width: 300 }}\n          onChange={this.handleSelected}\n          renderInput={(params) => (\n            <TextField {...params} label=\"Find Card...\" variant=\"outlined\" />\n          )}\n        />\n      </div>\n    );\n  }\n\n  private handleSelected = (_event: any, value: CardData | null) => {\n    if (!!value && !!this.props.cardSelected) {\n      this.props.cardSelected(value.code);\n    }\n  };\n\n  private cancelBubble = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {\n    event.stopPropagation();\n  };\n}\n\nexport default CardStackCardSelector;\n","import { connect } from \"react-redux\";\nimport CardStackCardSelector from \"./CardStackCardSelector\";\nimport { getCardsDataEntities } from \"./features/cards-data/cards-data.selectors\";\n\nimport { RootState } from \"./store/rootReducer\";\n\nconst mapStateToProps = (state: RootState) => {\n  return {\n    cardsDataEntities: getCardsDataEntities(state),\n  };\n};\n\nconst CardStackCardSelectorContainer = connect(\n  mapStateToProps,\n  {}\n)(CardStackCardSelector);\n\nexport default CardStackCardSelectorContainer;\n","import { Component } from \"react\";\nimport * as React from \"react\";\nimport { Vector2d } from \"konva/types/types\";\nimport { Group, Rect, Text } from \"react-konva\";\nimport { KonvaEventObject } from \"konva/types/Node\";\n\ninterface IProps {\n  id: string;\n  pos: Vector2d;\n  value: number;\n  updateCounterValueBy: (amount: number) => void;\n  handleContextMenu: (event: KonvaEventObject<PointerEvent>) => void;\n  onDragEnd: (event: KonvaEventObject<DragEvent>) => void;\n}\n\nclass Counter extends Component<IProps> {\n  render() {\n    return (\n      <Group\n        x={this.props.pos.x}\n        y={this.props.pos.y}\n        draggable={true}\n        onContextMenu={this.props.handleContextMenu}\n        onDragEnd={this.props.onDragEnd}\n      >\n        <Rect cornerRadius={30} width={200} height={100} fill={\"red\"}></Rect>\n        <Text\n          width={200}\n          height={100}\n          fontSize={36}\n          text={`${this.props.value}`}\n          align={\"center\"}\n          verticalAlign={\"middle\"}\n        ></Text>\n        <Text\n          x={10}\n          y={25}\n          width={50}\n          height={50}\n          fontSize={36}\n          text={`-`}\n          align={\"center\"}\n          verticalAlign={\"middle\"}\n          onClick={this.handleDecrement}\n        ></Text>\n        <Text\n          x={140}\n          y={25}\n          width={50}\n          height={50}\n          fontSize={36}\n          text={`+`}\n          align={\"center\"}\n          verticalAlign={\"middle\"}\n          onClick={this.handleIncrement}\n        ></Text>\n      </Group>\n    );\n  }\n\n  private handleDecrement = () => {\n    this.props.updateCounterValueBy(-1);\n  };\n\n  private handleIncrement = () => {\n    this.props.updateCounterValueBy(1);\n  };\n}\n\nexport default Counter;\n","import { Component } from \"react\";\nimport * as React from \"react\";\ninterface IProps {\n  connect: (peerId: string) => void;\n}\n\nclass PeerConnector extends Component<IProps> {\n  public inputRef: HTMLInputElement | null = null;\n\n  render() {\n    return (\n      <div onClick={this.cancelBubble}>\n        <input\n          ref={(ref) => {\n            if (!ref) return;\n            this.inputRef = ref;\n          }}\n        ></input>\n        <button onClick={this.connect}>Connect</button>\n      </div>\n    );\n  }\n\n  private connect = (_event: any) => {\n    console.log(\"connecting with peer id \" + this.inputRef?.value);\n\n    this.props.connect(this.inputRef?.value || \"\");\n  };\n\n  private cancelBubble = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {\n    event.stopPropagation();\n  };\n}\n\nexport default PeerConnector;\n","import { ReactReduxContext, Provider } from \"react-redux\";\nimport * as Intersects from \"intersects\";\nimport Konva from \"konva\";\nimport { KonvaEventObject } from \"konva/types/Node\";\nimport { Vector2d } from \"konva/types/types\";\nimport * as React from \"react\";\nimport { Component } from \"react\";\nimport { Layer, Rect, Stage } from \"react-konva\";\nimport \"./App.scss\";\nimport Card, { HORIZONTAL_TYPE_CODES } from \"./Card\";\nimport { cardConstants } from \"./constants/card-constants\";\nimport ContextMenu, { ContextMenuItem } from \"./ContextMenu\";\nimport DeckLoader from \"./DeckLoader\";\nimport EncounterLoaderContainer from \"./EncounterLoaderContainer\";\nimport { ICardData } from \"./features/cards-data/initialState\";\nimport {\n  CounterTokenType,\n  StatusTokenType,\n} from \"./features/cards/cards.slice\";\nimport { ICardsState, ICardStack } from \"./features/cards/initialState\";\nimport { IGameState } from \"./features/game/initialState\";\nimport TopLayer from \"./TopLayer\";\nimport { getDistance } from \"./utilities/geo\";\nimport CardStackCardSelectorContainer from \"./CardStackCardSelectorContainer\";\nimport Counter from \"./Counter\";\nimport PeerConnector from \"./PeerConnector\";\nimport { PlayerColor } from \"./constants/app-constants\";\nimport { ICounter } from \"./features/counters/initialState\";\n\nconst SCALE_BY = 1.02;\n\ninterface IProps {\n  cards: ICardsState;\n  cardsData: ICardData;\n  gameState: IGameState;\n  showPreview: boolean;\n  panMode: boolean;\n  playerColors: { [key: string]: PlayerColor };\n  cardMove: (info: { id: string; dx: number; dy: number }) => void;\n  endCardMove: (id: string) => void;\n  exhaustCard: (id: string) => void;\n  selectCard: (payload: { id: string; unselectOtherCards: boolean }) => void;\n  unselectCard: (id: string) => void;\n  toggleSelectCard: (id: string) => void;\n  startCardMove: (payload: { id: string; splitTopCard: boolean }) => void;\n  unselectAllCards: (payload?: any) => void;\n  selectMultipleCards: (cards: { ids: string[] }) => void;\n  hoverCard: (id: string) => void;\n  hoverLeaveCard: (id: string) => void;\n  togglePanMode: () => void;\n  flipCards: () => void;\n  loadCardsData: () => void;\n  shuffleStack: (id: string) => void;\n  fetchDecklistById: (payload: {\n    decklistId: number;\n    position: Vector2d;\n  }) => void;\n  updateZoom: (zoom: Vector2d) => void;\n  updatePosition: (pos: Vector2d) => void;\n  resetApp: () => void;\n  addCardStack: (payload: {\n    cardJsonIds: string[];\n    position: Vector2d;\n  }) => void;\n  toggleToken: (payload: {\n    id: string;\n    tokenType: StatusTokenType;\n    value: boolean;\n  }) => void;\n  adjustCounterToken: (payload: {\n    id: string;\n    tokenType: CounterTokenType;\n    delta: number;\n  }) => void;\n  pullCardOutOfCardStack: (payload: {\n    cardStackId: string;\n    jsonId: string;\n    pos: Vector2d;\n  }) => void;\n  addNewCounter: (pos: Vector2d) => void;\n  updateCounterValue: (payload: { id: string; delta: number }) => void;\n  removeCounter: (id: string) => void;\n  moveCounter: (payload: { id: string; newPos: Vector2d }) => void;\n  connectToRemoteGame: (peerId: string) => void;\n  undo: () => void;\n  redo: () => void;\n  counters: ICounter[];\n}\n\ninterface IState {\n  drewASelectionRect: boolean;\n  selectRect: {\n    height: number;\n    width: number;\n  };\n  selectStartPos: {\n    x: number;\n    y: number;\n  };\n  selecting: boolean;\n  showContextMenu: boolean;\n  contextMenuPosition: Vector2d | null;\n  contextMenuItems: ContextMenuItem[];\n  showDeckImporter: boolean;\n  deckImporterPosition: Vector2d | null;\n  showEncounterImporter: boolean;\n  encounterImporterPosition: Vector2d | null;\n  showCardSearch: boolean;\n  cardSearchPosition: Vector2d | null;\n  cardStackForSearching: ICardStack | null;\n  showPeerConnector: boolean;\n  peerConnectorPosition: Vector2d | null;\n}\nclass App extends Component<IProps, IState> {\n  public stage: Konva.Stage | null = null;\n\n  constructor(props: IProps) {\n    super(props);\n\n    this.state = {\n      drewASelectionRect: false,\n      selectRect: {\n        height: 0,\n        width: 0,\n      },\n      selectStartPos: {\n        x: 0,\n        y: 0,\n      },\n      selecting: false,\n      showContextMenu: false,\n      contextMenuPosition: null,\n      contextMenuItems: [],\n      showDeckImporter: false,\n      deckImporterPosition: null,\n      showEncounterImporter: false,\n      encounterImporterPosition: null,\n      showCardSearch: false,\n      cardSearchPosition: null,\n      cardStackForSearching: null,\n      showPeerConnector: false,\n      peerConnectorPosition: null,\n    };\n  }\n\n  public componentDidMount() {\n    this.props.loadCardsData();\n  }\n\n  public render() {\n    const staticCards = this.props.cards.cards\n      .filter((card) => !card.dragging)\n      .map((card) => {\n        return (\n          <Card\n            name={this.getCardName(card)}\n            selectedColor={\n              this.props.playerColors[card.controlledBy] ?? \"black\"\n            }\n            controlledBy={card.controlledBy}\n            key={card.id}\n            id={card.id}\n            x={card.x}\n            y={card.y}\n            exhausted={card.exhausted}\n            fill={card.fill}\n            selected={card.selected}\n            dropTarget={card.id === this.props.cards.dropTargetCard?.id}\n            dragging={card.dragging}\n            handleDragStart={this.handleCardDragStart}\n            handleDragMove={this.props.cardMove}\n            handleDragEnd={this.props.endCardMove}\n            handleDoubleClick={this.handleSelectAndExhaust}\n            handleClick={this.handleCardClick(card)}\n            handleHover={this.props.hoverCard}\n            handleHoverLeave={this.props.hoverLeaveCard}\n            handleContextMenu={this.handleCardContextMenu}\n            imgUrls={this.getImgUrls(card)}\n            typeCode={this.getCardType(card)}\n            faceup={card.faceup}\n            numCardsInStack={card.cardStack.length}\n            cardState={{\n              stunned: card.statusTokens.stunned,\n              confused: card.statusTokens.confused,\n              tough: card.statusTokens.tough,\n              tokens: { damage: 0, threat: 0, generic: 0 },\n            }}\n          />\n        );\n      });\n\n    const ghostCards = this.props.cards.ghostCards.map((card) => {\n      return (\n        <Card\n          name={this.getCardName(card)}\n          selectedColor={this.props.playerColors[card.controlledBy] ?? \"black\"}\n          controlledBy={card.controlledBy}\n          key={`ghost${card.id}`}\n          id={card.id}\n          x={card.x}\n          y={card.y}\n          exhausted={card.exhausted}\n          fill={card.fill}\n          selected={false}\n          dragging={false}\n          imgUrls={this.getImgUrls(card)}\n          typeCode={this.getCardType(card)}\n          faceup={card.faceup}\n          isGhost={true}\n        />\n      );\n    });\n\n    const movingCards = this.props.cards.cards\n      .filter((card) => card.dragging)\n      .map((card) => {\n        return (\n          <Card\n            name={this.getCardName(card)}\n            selectedColor={\n              this.props.playerColors[card.controlledBy] ?? \"black\"\n            }\n            controlledBy={card.controlledBy}\n            key={card.id}\n            id={card.id}\n            x={card.x}\n            y={card.y}\n            exhausted={card.exhausted}\n            fill={card.fill}\n            selected={card.selected}\n            dragging={card.dragging}\n            handleDragStart={this.handleCardDragStart}\n            handleDragMove={this.props.cardMove}\n            handleDragEnd={this.props.endCardMove}\n            imgUrls={this.getImgUrls(card)}\n            typeCode={this.getCardType(card)}\n            faceup={card.faceup}\n            numCardsInStack={card.cardStack.length}\n          />\n        );\n      });\n\n    const previewCards = this.stage\n      ? this.props.cards.cards\n          .filter(\n            (card) =>\n              !this.state.selecting &&\n              this.props.showPreview &&\n              !!this.props.cards.previewCard &&\n              card.id === this.props.cards.previewCard.id\n          )\n          .map((card) => {\n            const rawPos = this.getRawPreviewCardPosition();\n            const previewPos = this.getRelativePositionFromTarget(\n              this.stage,\n              rawPos\n            );\n            return (\n              <Card\n                name={this.getCardName(card)}\n                selectedColor={\n                  this.props.playerColors[card.controlledBy] ?? \"black\"\n                }\n                controlledBy={card.controlledBy}\n                key={`preview${card.id}`}\n                id={card.id}\n                x={previewPos.x}\n                y={previewPos.y}\n                exhausted={HORIZONTAL_TYPE_CODES.includes(\n                  this.getCardType(card)\n                )}\n                fill={card.fill}\n                selected={false}\n                dragging={false}\n                imgUrls={this.getImgUrls(card)}\n                typeCode={this.getCardType(card)}\n                faceup={card.faceup}\n                height={cardConstants.CARD_PREVIEW_HEIGHT}\n                width={cardConstants.CARD_PREVIEW_WIDTH}\n              />\n            );\n          })\n      : [];\n\n    return (\n      <div\n        tabIndex={1}\n        onKeyDown={this.handleKeyDown}\n        onKeyPress={this.handleKeyPress}\n      >\n        {this.renderEmptyMessage()}\n        {this.renderContextMenu()}\n        {this.renderDeckImporter()}\n        {this.renderEncounterImporter()}\n        {this.renderCardSearch()}\n        {this.renderPeerConnector()}\n        <ReactReduxContext.Consumer>\n          {({ store }) => (\n            <Stage\n              ref={(ref) => {\n                if (!ref) return;\n\n                this.stage = ref;\n              }}\n              x={this.props.gameState.stagePosition.x}\n              y={this.props.gameState.stagePosition.y}\n              width={window.innerWidth}\n              height={window.innerHeight}\n              onClick={this.handleStageClickOrTap}\n              onTap={this.handleStageClickOrTap}\n              onMouseDown={\n                this.props.panMode ? this.noOp : this.handleMouseDown\n              }\n              onMouseUp={this.props.panMode ? this.noOp : this.handleMouseUp}\n              onMouseMove={\n                this.props.panMode ? this.noOp : this.handleMouseMove\n              }\n              onTouchMove={\n                this.props.panMode ? this.noOp : this.handleMouseMove\n              }\n              onContextMenu={this.handleContextMenu}\n              scale={this.props.gameState.stageZoom}\n              onWheel={this.handleWheel}\n              draggable={this.props.panMode}\n              onDragMove={this.noOp}\n              onDragEnd={this.noOp}\n              preventDefault={true}\n            >\n              <Provider store={store}>\n                <Layer>\n                  {this.props.counters.map((counter) => (\n                    <Counter\n                      key={`${counter.id}-counter`}\n                      id={counter.id}\n                      pos={counter.position}\n                      value={counter.value}\n                      updateCounterValueBy={this.handleCounterValueUpdate(\n                        counter.id\n                      )}\n                      handleContextMenu={this.handleCounterContextMenu(\n                        counter.id\n                      )}\n                      onDragEnd={this.handleCounterDrag(counter.id)}\n                    ></Counter>\n                  ))}\n                </Layer>\n                <Layer preventDefault={true}>\n                  {staticCards\n                    .concat(ghostCards)\n                    .concat(movingCards)\n                    .concat(previewCards)}\n                </Layer>\n                <Layer>\n                  <Rect\n                    x={this.state.selectStartPos.x}\n                    y={this.state.selectStartPos.y}\n                    width={this.state.selectRect.width}\n                    height={this.state.selectRect.height}\n                    stroke=\"black\"\n                  />\n                </Layer>\n              </Provider>\n            </Stage>\n          )}\n        </ReactReduxContext.Consumer>\n      </div>\n    );\n  }\n\n  private handleCounterValueUpdate = (id: string) => (delta: number) => {\n    this.props.updateCounterValue({ id, delta });\n  };\n\n  private handleCounterDrag = (id: string) => (\n    event: KonvaEventObject<DragEvent>\n  ) => {\n    this.props.moveCounter({\n      id,\n      newPos: {\n        x: event.target.x(),\n        y: event.target.y(),\n      },\n    });\n  };\n\n  private noOp = () => {};\n\n  private renderEmptyMessage = () => {\n    if (this.props.cards.cards.length > 0) return null;\n\n    return (\n      <div>\n        Right click and select 'Load Deck ID' to load a deck from marvelcdb.com\n      </div>\n    );\n  };\n\n  private renderContextMenu = () => {\n    if (!this.state.showContextMenu) return null;\n\n    const containerRect = this.stage?.container().getBoundingClientRect();\n    const pointerPosition = this.state.contextMenuPosition;\n    if (!containerRect || !pointerPosition) {\n      throw new Error(\"Problem computing context menu position\");\n    }\n\n    return (\n      <ContextMenu\n        position={{\n          x: containerRect.left + pointerPosition.x,\n          y: containerRect.top + pointerPosition.y,\n        }}\n        items={this.state.contextMenuItems}\n        hideContextMenu={() => this.clearContextMenu()}\n      ></ContextMenu>\n    );\n  };\n\n  private renderDeckImporter = () => {\n    if (!this.state.showDeckImporter) return null;\n\n    const containerRect = this.stage?.container().getBoundingClientRect();\n    const pointerPosition = this.state.deckImporterPosition;\n    if (!containerRect || !pointerPosition) {\n      throw new Error(\"Problem computing deck importer position\");\n    }\n\n    return (\n      <TopLayer\n        position={{\n          x: containerRect.left + pointerPosition.x,\n          y: containerRect.top + pointerPosition.y,\n        }}\n        completed={this.clearDeckImporter}\n      >\n        <DeckLoader\n          loadDeckId={this.handleImportDeck(\n            this.getRelativePositionFromTarget(this.stage)\n          )}\n        />\n      </TopLayer>\n    );\n  };\n\n  private renderEncounterImporter = () => {\n    if (!this.state.showEncounterImporter) return null;\n\n    const containerRect = this.stage?.container().getBoundingClientRect();\n    const pointerPosition = this.state.encounterImporterPosition;\n    if (!containerRect || !pointerPosition) {\n      throw new Error(\"Problem computing deck importer position\");\n    }\n\n    const pos = {\n      x: containerRect.left + pointerPosition.x,\n      y: containerRect.top + pointerPosition.y,\n    };\n\n    return (\n      <TopLayer position={pos} completed={this.clearEncounterImporter}>\n        <EncounterLoaderContainer\n          loadCards={this.handleLoadEncounter(\n            this.getRelativePositionFromTarget(this.stage)\n          )}\n        />\n      </TopLayer>\n    );\n  };\n\n  private renderCardSearch = () => {\n    if (!this.state.showCardSearch) return null;\n\n    const containerRect = this.stage?.container().getBoundingClientRect();\n    const pointerPosition = this.state.cardSearchPosition;\n    if (!containerRect || !pointerPosition) {\n      throw new Error(\"Problem computing card search position\");\n    }\n\n    const pos = {\n      x: containerRect.left + pointerPosition.x,\n      y: containerRect.top + pointerPosition.y,\n    };\n\n    return !!this.state.cardStackForSearching ? (\n      <TopLayer position={pos} completed={this.clearCardSearch}>\n        <CardStackCardSelectorContainer\n          card={this.state.cardStackForSearching}\n          cardSelected={this.handleCardSelectedFromCardStack(\n            this.state.cardStackForSearching.id,\n            pos\n          )}\n        />\n      </TopLayer>\n    ) : null;\n  };\n\n  private renderPeerConnector = () => {\n    if (!this.state.showPeerConnector) return null;\n\n    const containerRect = this.stage?.container().getBoundingClientRect();\n    const pointerPosition = this.state.peerConnectorPosition;\n    if (!containerRect || !pointerPosition) {\n      throw new Error(\"Problem computing peer connector position\");\n    }\n\n    const pos = {\n      x: containerRect.left + pointerPosition.x,\n      y: containerRect.top + pointerPosition.y,\n    };\n\n    return !!this.state.showPeerConnector ? (\n      <TopLayer position={pos} completed={this.clearPeerConnector}>\n        <PeerConnector connect={this.handlePeerConnect}></PeerConnector>\n      </TopLayer>\n    ) : null;\n  };\n\n  private handleLoadEncounter = (position: Vector2d) => (cards: string[]) => {\n    this.clearEncounterImporter();\n    this.props.addCardStack({ position, cardJsonIds: cards });\n  };\n\n  private handleImportDeck = (position: Vector2d) => (id: number) => {\n    this.clearDeckImporter();\n    this.props.fetchDecklistById({ decklistId: id, position });\n  };\n\n  private handlePeerConnect = (peerId: string) => {\n    this.clearPeerConnector();\n    this.props.connectToRemoteGame(peerId);\n  };\n\n  private handleCardSelectedFromCardStack = (\n    cardStackId: string,\n    pos: Vector2d\n  ) => (jsonId: string) => {\n    this.clearCardSearch();\n    this.props.pullCardOutOfCardStack({ cardStackId, jsonId, pos });\n  };\n\n  private clearContextMenu = () => {\n    this.setState({\n      showContextMenu: false,\n      contextMenuPosition: null,\n      contextMenuItems: [],\n    });\n  };\n\n  private clearDeckImporter = () => {\n    this.setState({\n      showDeckImporter: false,\n      deckImporterPosition: null,\n    });\n  };\n\n  private clearEncounterImporter = () => {\n    this.setState({\n      showEncounterImporter: false,\n      encounterImporterPosition: null,\n    });\n  };\n\n  private clearCardSearch = () => {\n    this.setState({\n      showCardSearch: false,\n      cardSearchPosition: null,\n      cardStackForSearching: null,\n    });\n  };\n\n  private clearPeerConnector = () => {\n    this.setState({\n      showPeerConnector: false,\n      peerConnectorPosition: null,\n    });\n  };\n\n  private handleStageClickOrTap = (event: KonvaEventObject<MouseEvent>) => {\n    const mousePos = this.getRelativePositionFromTarget(this.stage);\n    if (\n      this.props.panMode ||\n      getDistance(this.state.selectStartPos, mousePos) < 30\n    ) {\n      this.props.unselectAllCards();\n    }\n  };\n\n  private handleWheel = (event: KonvaEventObject<WheelEvent>) => {\n    event.evt.preventDefault();\n\n    if (!this.stage) return;\n\n    var oldScale = this.props.gameState.stageZoom.x;\n\n    const pointer = this.stage.getPointerPosition() ?? { x: 0, y: 0 };\n\n    const mousePointTo = {\n      x: (pointer.x - this.stage.x()) / oldScale,\n      y: (pointer.y - this.stage.y()) / oldScale,\n    };\n\n    const newScale =\n      event.evt.deltaY < 0 ? oldScale * SCALE_BY : oldScale / SCALE_BY;\n\n    this.props.updateZoom({ x: newScale, y: newScale });\n\n    const newPos = {\n      x: pointer.x - mousePointTo.x * newScale,\n      y: pointer.y - mousePointTo.y * newScale,\n    };\n\n    this.props.updatePosition(newPos);\n  };\n\n  private handleCounterContextMenu = (counterId: string) => (\n    event: KonvaEventObject<PointerEvent>\n  ) => {\n    event.evt.preventDefault();\n    event.cancelBubble = true;\n\n    const menuItems = [\n      {\n        label: \"Remove\",\n        action: () => {\n          this.props.removeCounter(counterId);\n        },\n      },\n    ];\n\n    this.setState({\n      showContextMenu: true,\n      contextMenuPosition: this.stage?.getPointerPosition() ?? null,\n      contextMenuItems: menuItems,\n    });\n  };\n\n  private handleCardContextMenu = (\n    cardId: string,\n    event: KonvaEventObject<PointerEvent>\n  ) => {\n    event.evt.preventDefault();\n    event.cancelBubble = true;\n\n    // First, select the card\n    this.props.selectCard({ id: cardId, unselectOtherCards: false });\n\n    const card = this.props.cards.cards.find((c) => c.id === cardId);\n    const numCardsInStack = card?.cardStack?.length || 0;\n    const currentStatusTokens = card?.statusTokens || {\n      stunned: false,\n      confused: false,\n      tough: false,\n    };\n\n    const menuItems = [\n      {\n        label: \"Flip\",\n        action: () => {\n          this.props.flipCards();\n        },\n      },\n    ];\n\n    if (numCardsInStack > 1) {\n      menuItems.push({\n        label: \"Shuffle\",\n        action: () => {\n          this.props.shuffleStack(cardId);\n        },\n      });\n\n      menuItems.push({\n        label: \"Find Specific Card\",\n        action: () => {\n          if (!!card) {\n            this.setState({\n              showCardSearch: true,\n              cardSearchPosition: this.stage?.getPointerPosition() ?? null,\n              cardStackForSearching: card,\n            });\n          }\n        },\n      });\n    }\n\n    menuItems.push({\n      label: !!currentStatusTokens.stunned ? \"Remove Stun\" : \"Stun\",\n      action: () => {\n        this.props.toggleToken({\n          id: card?.id || \"\",\n          tokenType: StatusTokenType.Stunned,\n          value: !currentStatusTokens.stunned,\n        });\n      },\n    });\n\n    menuItems.push({\n      label: !!currentStatusTokens.confused ? \"Remove Confused\" : \"Confuse\",\n      action: () => {\n        this.props.toggleToken({\n          id: card?.id || \"\",\n          tokenType: StatusTokenType.Confused,\n          value: !currentStatusTokens.confused,\n        });\n      },\n    });\n\n    menuItems.push({\n      label: !!currentStatusTokens.tough ? \"Remove Tough\" : \"Tough\",\n      action: () => {\n        this.props.toggleToken({\n          id: card?.id || \"\",\n          tokenType: StatusTokenType.Tough,\n          value: !currentStatusTokens.tough,\n        });\n      },\n    });\n\n    menuItems.push({\n      label: \"Add 1 Damage\",\n      action: () => {\n        this.props.adjustCounterToken({\n          id: card?.id || \"\",\n          tokenType: CounterTokenType.Damage,\n          delta: 1,\n        });\n      },\n    });\n\n    menuItems.push({\n      label: \"Remove 1 Damage\",\n      action: () => {\n        this.props.adjustCounterToken({\n          id: card?.id || \"\",\n          tokenType: CounterTokenType.Damage,\n          delta: -1,\n        });\n      },\n    });\n\n    menuItems.push({\n      label: \"Add 1 Threat\",\n      action: () => {\n        this.props.adjustCounterToken({\n          id: card?.id || \"\",\n          tokenType: CounterTokenType.Threat,\n          delta: 1,\n        });\n      },\n    });\n\n    menuItems.push({\n      label: \"Remove 1 Threat\",\n      action: () => {\n        this.props.adjustCounterToken({\n          id: card?.id || \"\",\n          tokenType: CounterTokenType.Threat,\n          delta: -1,\n        });\n      },\n    });\n\n    menuItems.push({\n      label: \"Add 1 Generic Token\",\n      action: () => {\n        this.props.adjustCounterToken({\n          id: card?.id || \"\",\n          tokenType: CounterTokenType.Generic,\n          delta: 1,\n        });\n      },\n    });\n\n    menuItems.push({\n      label: \"Remove 1 Generic Token\",\n      action: () => {\n        this.props.adjustCounterToken({\n          id: card?.id || \"\",\n          tokenType: CounterTokenType.Generic,\n          delta: -1,\n        });\n      },\n    });\n\n    this.setState({\n      showContextMenu: true,\n      contextMenuPosition: this.stage?.getPointerPosition() ?? null,\n      contextMenuItems: menuItems,\n    });\n  };\n\n  private handleCardClick = (card: ICardStack) => (\n    cardId: string,\n    event: KonvaEventObject<MouseEvent>\n  ) => {\n    // Here check if modifier held down\n    const modifierKeyHeld =\n      event.evt.shiftKey || event.evt.metaKey || event.evt.ctrlKey;\n\n    if (card.selected && modifierKeyHeld) {\n      this.props.toggleSelectCard(cardId);\n    } else {\n      this.props.selectCard({\n        id: cardId,\n        unselectOtherCards: !modifierKeyHeld,\n      });\n    }\n  };\n\n  private handleSelectAndExhaust = (\n    cardId: string,\n    event: KonvaEventObject<MouseEvent>\n  ) => {\n    // Here check if modifier held down\n    const modifierKeyHeld =\n      event.evt.shiftKey || event.evt.metaKey || event.evt.ctrlKey;\n    this.props.selectCard({ id: cardId, unselectOtherCards: !modifierKeyHeld });\n    this.props.exhaustCard(cardId);\n  };\n\n  private handleCardDragStart = (\n    cardId: string,\n    event: KonvaEventObject<DragEvent>\n  ) => {\n    let splitTopCard = false;\n    // If multiple things are selected, you can't pull something off the top of a stack,\n    // so just do a normal drag\n    const multipleSelected =\n      this.props.cards.cards.filter((c) => c.selected).length > 1;\n\n    if (!multipleSelected) {\n      const draggingCard = this.props.cards.cards.find((c) => c.id === cardId);\n      const hasStack = (draggingCard?.cardStack || []).length > 1;\n      if (!!draggingCard && hasStack) {\n        // Check if we're dragging in the upper right corner of the card\n        const upperRightPoint = {\n          x: draggingCard.x + cardConstants.CARD_WIDTH / 2,\n          y: draggingCard.y - cardConstants.CARD_HEIGHT / 2,\n        };\n        const distance = getDistance(\n          upperRightPoint,\n          this.getRelativePositionFromTarget(this.stage)\n        );\n        if (distance < 30) {\n          splitTopCard = true;\n        }\n      }\n    }\n\n    this.props.startCardMove({ id: cardId, splitTopCard });\n  };\n\n  private handleKeyPress = (event: React.KeyboardEvent<HTMLElement>) => {\n    const code = event.which || event.keyCode;\n    if (code === 115) {\n      this.props.togglePanMode();\n    } else if (code === 102) {\n      this.props.flipCards();\n    }\n  };\n\n  private handleKeyDown = (event: React.KeyboardEvent<HTMLElement>) => {\n    if (\n      event.shiftKey &&\n      (event.ctrlKey || event.metaKey) &&\n      event.key === \"z\"\n    ) {\n      this.props.redo();\n    } else if ((event.ctrlKey || event.metaKey) && event.key === \"z\") {\n      event.preventDefault();\n      this.props.undo();\n    }\n  };\n\n  private getRawPreviewCardPosition = (): Vector2d => {\n    const pointerPos = this.stage?.getPointerPosition() ?? { x: 0, y: 0 };\n    const screenMidPointX = window.innerWidth / 2;\n    return pointerPos.x < screenMidPointX\n      ? {\n          x: window.innerWidth - cardConstants.CARD_PREVIEW_WIDTH / 2,\n          y: cardConstants.CARD_PREVIEW_HEIGHT / 2,\n        }\n      : {\n          x: cardConstants.CARD_PREVIEW_WIDTH / 2,\n          y: cardConstants.CARD_PREVIEW_HEIGHT / 2,\n        };\n  };\n\n  private getRelativePositionFromTarget = (\n    target: any,\n    posParam?: Vector2d\n  ) => {\n    const transform = target.getAbsoluteTransform().copy();\n    transform.invert();\n    let pos = posParam || target.getPointerPosition();\n    return transform.point(pos) as Vector2d;\n  };\n\n  private handleMouseDown = (event: KonvaEventObject<MouseEvent>) => {\n    if (event.evt.button === 0) {\n      // Only do something if it's the primary button (not a right-click)\n      const pos = this.getRelativePositionFromTarget(this.stage);\n\n      this.setState({\n        selectStartPos: {\n          x: pos.x,\n          y: pos.y,\n        },\n        selecting: true,\n      });\n    }\n\n    return false;\n  };\n\n  private getSelectionRectInfo = () => {\n    const selectStartPos = this.state.selectStartPos;\n    const selectRect = this.state.selectRect;\n    return {\n      height: Math.abs(selectRect.height),\n      width: Math.abs(selectRect.width),\n      x:\n        selectRect.width < 0\n          ? selectStartPos.x + selectRect.width\n          : selectStartPos.x,\n      y:\n        selectRect.height < 0\n          ? selectStartPos.y + selectRect.height\n          : selectStartPos.y,\n    };\n  };\n\n  private handleMouseUp = () => {\n    // if we were selecting, check for intersection\n    if (this.state.drewASelectionRect) {\n      const selectRect = this.getSelectionRectInfo();\n      const selectedCards: any[] = this.props.cards.cards.reduce<ICardStack[]>(\n        (currSelectedCards, card) => {\n          const intersects = Intersects.boxBox(\n            selectRect.x,\n            selectRect.y,\n            selectRect.width,\n            selectRect.height,\n            card.x - 50,\n            card.y - 75,\n            cardConstants.CARD_WIDTH,\n            cardConstants.CARD_HEIGHT\n          );\n\n          if (intersects) {\n            currSelectedCards.push(card);\n          }\n\n          return currSelectedCards;\n        },\n        []\n      );\n\n      this.props.selectMultipleCards({\n        ids: selectedCards.map((card) => card.id),\n      });\n    }\n\n    this.setState({\n      drewASelectionRect: false,\n      selectRect: {\n        height: 0,\n        width: 0,\n      },\n      selecting: false,\n    });\n\n    return false;\n  };\n\n  private handleMouseMove = (event: any) => {\n    if (this.state.selecting) {\n      const pos = this.getRelativePositionFromTarget(event.currentTarget);\n      this.setState({\n        drewASelectionRect: true,\n        selectRect: {\n          height: pos.y - this.state.selectStartPos.y,\n          width: pos.x - this.state.selectStartPos.x,\n        },\n      });\n    }\n    event.cancelBubble = true;\n  };\n\n  private handleContextMenu = (event: KonvaEventObject<PointerEvent>): void => {\n    event.evt.preventDefault();\n    event.cancelBubble = true;\n\n    const menuItems = [\n      {\n        label: \"Load Deck ID\",\n        action: () => {\n          this.setState({\n            showDeckImporter: true,\n            deckImporterPosition: this.stage?.getPointerPosition() ?? null,\n          });\n        },\n      },\n      {\n        label: \"Load Encounter\",\n        action: () => {\n          this.setState({\n            showEncounterImporter: true,\n            encounterImporterPosition: this.stage?.getPointerPosition() ?? null,\n          });\n        },\n      },\n      {\n        label: \"Create new counter\",\n        action: () => {\n          this.props.addNewCounter(\n            this.getRelativePositionFromTarget(this.stage) ?? { x: 0, y: 0 }\n          );\n        },\n      },\n      { label: \"Reset\", action: this.props.resetApp },\n      {\n        label: \"Connect to Remote Game\",\n        action: () => {\n          this.setState({\n            showPeerConnector: true,\n            peerConnectorPosition: this.stage?.getPointerPosition() ?? null,\n          });\n        },\n      },\n    ];\n\n    this.setState({\n      showContextMenu: true,\n      contextMenuPosition: this.stage?.getPointerPosition() ?? null,\n      contextMenuItems: menuItems,\n    });\n  };\n\n  private getCardType = (card: ICardStack): string => {\n    if (Object.keys(this.props.cardsData).length === 0) return \"\";\n\n    const cardData = this.props.cardsData[card.cardStack[0].jsonId];\n\n    return cardData.type_code;\n  };\n\n  private getCardName = (card: ICardStack) => {\n    const cardInQuestion = card.faceup\n      ? card.cardStack[0]\n      : card.cardStack[card.cardStack.length - 1];\n    return this.props.cardsData[cardInQuestion.jsonId]?.name ?? \"\";\n  };\n\n  private getImgUrls = (card: ICardStack): string[] => {\n    if (Object.keys(this.props.cardsData).length === 0) return [\"\"];\n\n    const topCardData = this.props.cardsData[card.cardStack[0].jsonId];\n    const bottomCardData = this.props.cardsData[\n      card.cardStack[card.cardStack.length - 1].jsonId\n    ];\n\n    if (\n      !card.faceup &&\n      (!!bottomCardData.back_link || !!bottomCardData.double_sided)\n    ) {\n      // console.log(\"back side\");\n      // console.log(bottomCardData);\n      return [\n        `https://marvelcdb.com/bundles/cards/${bottomCardData.back_link}.png`,\n        `https://marvelcdb.com/bundles/cards/${bottomCardData.back_link}.jpg`,\n        process.env.PUBLIC_URL +\n          \"/images/cards/\" +\n          bottomCardData.octgn_id +\n          \".b.jpg\",\n      ];\n    } else if (!card.faceup) {\n      return [process.env.PUBLIC_URL + \"/images/standard/card_back.png\"];\n    }\n\n    return [\n      `https://marvelcdb.com/bundles/cards/${topCardData.code}.png`,\n      `https://marvelcdb.com/bundles/cards/${topCardData.code}.jpg`,\n      process.env.PUBLIC_URL + \"/images/cards/\" + topCardData.octgn_id + \".jpg\",\n    ];\n  };\n}\n\nexport default App;\n","import { createSlice, CaseReducer } from \"@reduxjs/toolkit\";\nimport { initialState, ICardsDataState } from \"./initialState\";\n\nimport * as PackData from \"../../external/generated/packs\";\nimport { CardData } from \"../../external-api/marvel-card-data\";\nimport SetData from \"../../external/marvelsdb-json-data/sets.json\";\n\n// Reducers\nconst loadCardsDataReducer: CaseReducer<ICardsDataState> = (state) => {\n  //This reducer is only intended to be called a single time each load.\n  state.entities = {};\n  state.encounterEntities = {};\n  const heroPacks = Object.entries(PackData)\n    .filter(([key, value]) => !key.includes(\"_encounter\"))\n    .map(([key, value]) => value);\n\n  const encounterPacks = Object.entries(PackData)\n    .filter(([key, value]) => key.includes(\"_encounter\"))\n    .map(([key, value]) => value);\n\n  heroPacks.forEach((pack) =>\n    pack.forEach((card: CardData) => {\n      if (state.entities[card.code]) {\n        console.error(\"Found multiple cards with code \" + card.code);\n      }\n\n      // if (!card.octgn_id) {\n      //   console.error(`Card ${card.code} had no octgn_id!`);\n      // }\n\n      state.entities[card.code] = card;\n    })\n  );\n\n  encounterPacks.forEach((pack) =>\n    pack.forEach((card: CardData) => {\n      if (state.encounterEntities[card.code]) {\n        console.error(\"Found multiple cards with code \" + card.code);\n      }\n\n      // if (!card.octgn_id) {\n      //   console.error(`Card ${card.code}: ${card.name} had no octgn_id!`);\n      // }\n\n      state.encounterEntities[card.code] = card;\n    })\n  );\n\n  SetData.forEach((set) => {\n    state.setData[set.code] = {\n      name: set.name,\n      setTypeCode: set.card_set_type_code,\n    };\n  });\n\n  return state;\n};\n\n// slice\nconst cardsDataSlice = createSlice({\n  name: \"cardsData\",\n  initialState: initialState,\n  reducers: {\n    loadCardsData: loadCardsDataReducer,\n  },\n});\n\nexport const { loadCardsData } = cardsDataSlice.actions;\n\nexport default cardsDataSlice.reducer;\n","import { CardData } from \"../../external-api/marvel-card-data\";\n\nexport interface ICardData {\n  [key: string]: CardData;\n}\n\nexport interface Set {\n  name: string;\n  setTypeCode: string;\n}\n\nexport interface ISetData {\n  [key: string]: Set;\n}\n\nexport interface ICardsDataState {\n  entities: ICardData;\n  encounterEntities: ICardData;\n  setData: ISetData;\n}\n\nexport const initialState: ICardsDataState = {\n  entities: {},\n  encounterEntities: {},\n  setData: {},\n};\n","import { createSelector } from \"@reduxjs/toolkit\";\nimport { RootState } from \"../../store/rootReducer\";\n\nexport const getGame = (state: RootState) => state.game;\n\nexport const getCurrentZoom = createSelector(getGame, (game) => {\n  return game.stageZoom;\n});\n\nexport const getPlayerColors = createSelector(getGame, (game) => {\n  return game.playerColors;\n});\n","import { Vector2d } from \"konva/types/types\";\nimport { myPeerRef, PlayerColor } from \"../../constants/app-constants\";\nimport { loadState } from \"../../store/localStorage\";\n\nexport interface IGameState {\n  stageZoom: Vector2d;\n  stagePosition: Vector2d;\n  playerColors: { [key: string]: PlayerColor };\n}\n\nconst localStorageState: IGameState = loadState(\"game\");\nlocalStorageState.playerColors = {};\nlocalStorageState.playerColors[myPeerRef] = \"red\";\n\nconst defaultState: IGameState = {\n  playerColors: {},\n  stageZoom: { x: 1, y: 1 },\n  stagePosition: { x: 0, y: 0 },\n};\nexport const initialState: IGameState = {\n  ...defaultState,\n  ...localStorageState,\n};\n","import { CaseReducer, createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport { Vector2d } from \"konva/types/types\";\nimport { PlayerColor } from \"../../constants/app-constants\";\nimport { resetApp } from \"../../store/global.actions\";\nimport { IGameState, initialState } from \"./initialState\";\n\n// Reducers\nconst updateZoomReducer: CaseReducer<IGameState, PayloadAction<Vector2d>> = (\n  state,\n  action\n) => {\n  state.stageZoom = action.payload;\n  return state;\n};\n\nconst updatePositionReducer: CaseReducer<\n  IGameState,\n  PayloadAction<Vector2d>\n> = (state, action) => {\n  state.stagePosition = action.payload;\n  return state;\n};\n\nconst connectToRemoteGameReducer: CaseReducer<\n  IGameState,\n  PayloadAction<string>\n> = (state, action) => {};\n\nconst setPlayerColorReducer: CaseReducer<\n  IGameState,\n  PayloadAction<{ ref: string; color: PlayerColor }>\n> = (state, action) => {\n  state.playerColors[action.payload.ref] = action.payload.color;\n};\n\n// slice\nconst gameSlice = createSlice({\n  name: \"game\",\n  initialState: initialState,\n  reducers: {\n    updateZoom: updateZoomReducer,\n    updatePosition: updatePositionReducer,\n    connectToRemoteGame: connectToRemoteGameReducer,\n    setPlayerColor: setPlayerColorReducer,\n  },\n  extraReducers: (builder) => {\n    builder.addCase(resetApp, (state, action) => {\n      state.stagePosition = { x: 0, y: 0 };\n      state.stageZoom = { x: 1, y: 1 };\n    });\n  },\n});\n\nexport const {\n  updateZoom,\n  updatePosition,\n  connectToRemoteGame,\n  setPlayerColor,\n} = gameSlice.actions;\n\nexport default gameSlice.reducer;\n","import { createAction } from \"@reduxjs/toolkit\";\nimport { Vector2d } from \"konva/types/types\";\n\nexport interface AddNewCounterWithIdPayload {\n  pos: Vector2d;\n  id: string;\n}\n\nexport const addNewCounterWithId = createAction<AddNewCounterWithIdPayload>(\n  \"addNewCounterWithId\"\n);\n","import { Vector2d } from \"konva/types/types\";\nimport { loadState } from \"../../store/localStorage\";\n\nexport interface ICountersState {\n  counters: ICounter[];\n}\n\nexport interface ICounter {\n  id: string;\n  position: Vector2d;\n  value: number;\n}\n\nconst localStorageState: ICountersState = loadState(\"counters\");\n\nconst defaultState: ICountersState = {\n  counters: [],\n};\nexport const initialState: ICountersState = {\n  ...defaultState,\n  ...localStorageState,\n};\n","import { CaseReducer, createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport { Vector2d } from \"konva/types/types\";\nimport { receiveRemoteGameState, resetApp } from \"../../store/global.actions\";\nimport { addNewCounterWithId } from \"./counters.actions\";\nimport { ICountersState, initialState } from \"./initialState\";\n\n// Reducers\nconst updateCounterValueReducer: CaseReducer<\n  ICountersState,\n  PayloadAction<{ id: string; delta: number }>\n> = (state, action) => {\n  const counter = state.counters.find((c) => c.id === action.payload.id);\n  if (!!counter) {\n    counter.value += action.payload.delta;\n    if (counter.value < 0) {\n      counter.value = 0;\n    }\n  }\n};\n\nconst removeCounterReducer: CaseReducer<\n  ICountersState,\n  PayloadAction<string>\n> = (state, action) => {\n  state.counters = state.counters.filter((c) => c.id !== action.payload);\n};\n\nconst moveCounterReducer: CaseReducer<\n  ICountersState,\n  PayloadAction<{ id: string; newPos: Vector2d }>\n> = (state, action) => {\n  const counter = state.counters.find((c) => c.id === action.payload.id);\n  if (!!counter) {\n    counter.position = {\n      x: action.payload.newPos.x,\n      y: action.payload.newPos.y,\n    };\n  }\n};\n\n// slice\nconst countersSlice = createSlice({\n  name: \"counters\",\n  initialState: initialState,\n  reducers: {\n    updateCounterValue: updateCounterValueReducer,\n    removeCounter: removeCounterReducer,\n    moveCounter: moveCounterReducer,\n  },\n  extraReducers: (builder) => {\n    builder.addCase(receiveRemoteGameState, (state, action) => {\n      // TODO: find a way to keep this automatic\n      state.counters = action.payload.counters.present.counters;\n    });\n\n    builder.addCase(resetApp, (state, action) => {\n      state.counters = [];\n    });\n\n    builder.addCase(addNewCounterWithId, (state, action) => {\n      state.counters.push({\n        id: action.payload.id,\n        position: action.payload.pos,\n        value: 0,\n      });\n    });\n  },\n});\n\nexport const {\n  updateCounterValue,\n  removeCounter,\n  moveCounter,\n} = countersSlice.actions;\n\nexport default countersSlice.reducer;\n","import { createSelector } from \"@reduxjs/toolkit\";\nimport { RootState } from \"../../store/rootReducer\";\n\nexport const getCounters = (state: RootState) => state.counters.present;\n\nexport const getCurrentCounters = createSelector(getCounters, (counters) => {\n  return counters.counters;\n});\n","import { connect } from \"react-redux\";\nimport { ActionCreators } from \"redux-undo\";\nimport App from \"./App\";\nimport { getCardsDataEntities } from \"./features/cards-data/cards-data.selectors\";\nimport { loadCardsData } from \"./features/cards-data/cards-data.slice\";\nimport {\n  getCards,\n  getPanMode,\n  shouldShowPreview,\n} from \"./features/cards/cards.selectors\";\nimport {\n  adjustCounterToken,\n  cardMove,\n  endCardMove,\n  exhaustCard,\n  flipCards,\n  hoverCard,\n  hoverLeaveCard,\n  selectCard,\n  selectMultipleCards,\n  togglePanMode,\n  toggleSelectCard,\n  toggleToken,\n  unselectAllCards,\n  unselectCard,\n} from \"./features/cards/cards.slice\";\nimport {\n  addCardStack,\n  fetchDecklistById,\n  pullCardOutOfCardStack,\n  startCardMove,\n  shuffleStack,\n} from \"./features/cards/cards.thunks\";\nimport { getGame, getPlayerColors } from \"./features/game/game.selectors\";\nimport {\n  connectToRemoteGame,\n  updatePosition,\n  updateZoom,\n} from \"./features/game/game.slice\";\n\nimport {\n  moveCounter,\n  removeCounter,\n  updateCounterValue,\n} from \"./features/counters/counters.slice\";\nimport { addNewCounter } from \"./features/counters/counters.thunks\";\nimport { resetApp } from \"./store/global.actions\";\nimport { RootState } from \"./store/rootReducer\";\nimport { getCurrentCounters } from \"./features/counters/counters.selectors\";\n\nconst mapStateToProps = (state: RootState) => {\n  return {\n    playerColors: getPlayerColors(state),\n    cards: getCards(state),\n    cardsData: getCardsDataEntities(state),\n    showPreview: shouldShowPreview(state),\n    panMode: getPanMode(state),\n    gameState: getGame(state),\n    counters: getCurrentCounters(state),\n  };\n};\n\nconst AppContainer = connect(mapStateToProps, {\n  cardMove,\n  endCardMove,\n  exhaustCard,\n  loadCardsData,\n  selectCard,\n  unselectCard,\n  toggleSelectCard,\n  selectMultipleCards,\n  startCardMove,\n  unselectAllCards,\n  hoverCard,\n  hoverLeaveCard,\n  togglePanMode,\n  flipCards,\n  shuffleStack,\n  fetchDecklistById,\n  updateZoom,\n  updatePosition,\n  resetApp,\n  addCardStack,\n  toggleToken,\n  adjustCounterToken,\n  pullCardOutOfCardStack,\n  addNewCounter,\n  updateCounterValue,\n  removeCounter,\n  moveCounter,\n  connectToRemoteGame,\n  undo: ActionCreators.undo,\n  redo: ActionCreators.redo,\n})(App);\n\nexport default AppContainer;\n","import { Vector2d } from \"konva/types/types\";\nimport { Action } from \"redux\";\nimport { ThunkAction } from \"redux-thunk\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { RootState } from \"../../store/rootReducer\";\nimport { addNewCounterWithId } from \"./counters.actions\";\n\nexport const addNewCounter = (\n  pos: Vector2d\n): ThunkAction<void, RootState, unknown, Action<string>> => (dispatch) => {\n  const payloadWithId = {\n    pos,\n    id: uuidv4(),\n  };\n  dispatch(addNewCounterWithId(payloadWithId));\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import { combineReducers } from \"redux\";\nimport undoable, { excludeAction, groupByActionTypes } from \"redux-undo\";\nimport cardsData from \"../features/cards-data/cards-data.slice\";\nimport { startCardMoveWithSplitStackId } from \"../features/cards/cards.actions\";\nimport cards, {\n  cardMove,\n  hoverCard,\n  hoverLeaveCard,\n} from \"../features/cards/cards.slice\";\nimport game from \"../features/game/game.slice\";\n\nimport counters, { moveCounter } from \"../features/counters/counters.slice\";\n\nconst rootReducer = combineReducers({\n  game,\n  counters: undoable(counters, {\n    limit: 20,\n    groupBy: groupByActionTypes([moveCounter.type]),\n  }),\n  cards: undoable(cards, {\n    limit: 20,\n    filter: excludeAction([\n      startCardMoveWithSplitStackId.type,\n      cardMove.type,\n      hoverCard.type,\n      hoverLeaveCard.type,\n    ]),\n  }),\n  cardsData,\n});\n\nexport type RootState = ReturnType<typeof rootReducer>;\n\nexport default rootReducer;\n","import Peer from \"peerjs\";\nimport { myPeerRef } from \"../constants/app-constants\";\nimport {\n  hoverCard,\n  hoverLeaveCard,\n  togglePanMode,\n} from \"../features/cards/cards.slice\";\nimport {\n  connectToRemoteGame,\n  setPlayerColor,\n  updatePosition,\n  updateZoom,\n} from \"../features/game/game.slice\";\nimport { receiveRemoteGameState } from \"./global.actions\";\n\nconst DEBUG = false;\n\nconst blacklistRemoteActions = {\n  [connectToRemoteGame.type]: true,\n  [updatePosition.type]: true,\n  [updateZoom.type]: true,\n  [hoverCard.type]: true,\n  [hoverLeaveCard.type]: true,\n  [togglePanMode.type]: true,\n  [receiveRemoteGameState.type]: true,\n};\n\nconst log = (...args: any[]) => {\n  if (DEBUG) {\n    console.log(args[0], args[1]);\n  }\n};\n\nconst setupConnection = (conn: any, storeAPI: any) => {\n  conn.on(\"data\", (data: any) => {\n    if (!data.INITIAL_STATE_MSG) {\n      log(\"recieved remote action\", data);\n      data.REMOTE_ACTION = true;\n      log(\"dispatching remote action\", data);\n      storeAPI.dispatch(data);\n    } else {\n      console.log(\"going to replace (most of) state with\", data.state);\n      setTimeout(() => {\n        storeAPI.dispatch(receiveRemoteGameState(data.state));\n      }, 0);\n    }\n  });\n};\n\nexport const peerJSMiddleware = (storeAPI: any) => {\n  const cgpPeer = new Peer(undefined, { debug: 3 });\n  let activeCon: Peer.DataConnection;\n  cgpPeer.on(\"error\", (err) => {\n    console.error(\"*****************Server error\");\n    console.error(err);\n  });\n\n  cgpPeer.on(\"disconnected\", () => {\n    console.log(\"****Peer server connection disconnected\");\n  });\n\n  cgpPeer.on(\"open\", (id) => {\n    console.log(\"My peer ID is: \" + id);\n  });\n\n  cgpPeer.on(\"connection\", (conn) => {\n    console.log(\"Connection received!\");\n    activeCon = conn;\n    setupConnection(activeCon, storeAPI);\n\n    activeCon.on(\"open\", () => {\n      console.log(\"connection ready for data\");\n      log(\"going to send initial state\", storeAPI.getState());\n      activeCon.send({\n        INITIAL_STATE_MSG: true,\n        state: storeAPI.getState(),\n      });\n      // TODO: more complicated logic to handle multiple connections. Right now\n      // this just changes the connecting client to blue\n      const setPlayerColorAction = setPlayerColor({\n        ref: activeCon.metadata.ref,\n        color: \"blue\",\n      });\n      activeCon.send(setPlayerColorAction);\n      activeCon.send(\n        setPlayerColor({\n          ref: myPeerRef,\n          color: \"red\",\n        })\n      );\n      storeAPI.dispatch(setPlayerColorAction);\n    });\n\n    activeCon.on(\"error\", (err) => {\n      console.error(\"****************Connection error:\", err);\n    });\n\n    activeCon.on(\"close\", () => {\n      console.log(\"******connection closed for ref \" + activeCon.metadata.ref);\n    });\n\n    activeCon.peerConnection.onconnectionstatechange = (ev: Event) => {\n      console.log(`connection state changed`);\n      console.log(ev);\n      console.log(activeCon.peerConnection.connectionState);\n      if (\n        activeCon.peerConnection.connectionState === \"closed\" ||\n        activeCon.peerConnection.connectionState === \"disconnected\"\n      ) {\n        console.log(\n          \"CLEARING CLIENT OWNED CARDS for \" + activeCon.metadata.ref\n        );\n      }\n    };\n  });\n  return (next: any) => (action: any) => {\n    log(\"received local action\", action);\n\n    // If this isn't a REMOTE action, add our ref onto it\n    if (!action.REMOTE_ACTION) {\n      action.ACTOR_REF = myPeerRef;\n    } else if (!action.ACTOR_REF) {\n      console.error(`Received a REMOTE action without an ACTOR_REF:`);\n      console.log(action);\n    }\n\n    if (action.type === connectToRemoteGame.type) {\n      console.log(\"going to connect to peer \" + action.payload);\n      activeCon = cgpPeer.connect(action.payload, {\n        metadata: { ref: myPeerRef },\n      });\n      setupConnection(activeCon, storeAPI);\n    }\n\n    if (\n      !action.REMOTE_ACTION &&\n      !!activeCon &&\n      !blacklistRemoteActions[action.type]\n    ) {\n      log(\"going to send action to peer!\");\n      activeCon.send(action);\n    }\n\n    return next(action);\n  };\n};\n","import throttle from \"lodash.throttle\";\nimport {\n  configureStore as rtkConfigureStore,\n  getDefaultMiddleware,\n} from \"@reduxjs/toolkit\";\nimport rootReducer from \"./rootReducer\";\nimport { saveState } from \"./localStorage\";\nimport { peerJSMiddleware } from \"./peer-js-redux-middleware\";\n\nconst customizedMiddleware = getDefaultMiddleware({\n  thunk: true,\n  immutableCheck: false,\n  serializableCheck: false,\n}).concat(peerJSMiddleware);\n\nexport default function configureStore() {\n  console.log(\"configuring store. NODE_ENV is \" + process.env.NODE_ENV);\n  const store = rtkConfigureStore({\n    reducer: rootReducer,\n    middleware: customizedMiddleware,\n    devTools: process.env.NODE_ENV !== \"production\",\n  });\n\n  store.subscribe(\n    throttle(() => {\n      saveState(store.getState());\n    }, 1000)\n  );\n\n  return store;\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.scss\";\nimport { Provider } from \"react-redux\";\nimport AppContainer from \"./AppContainer\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport configureStore from \"./store/configureStore\";\n\nconst store = configureStore();\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <AppContainer />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}