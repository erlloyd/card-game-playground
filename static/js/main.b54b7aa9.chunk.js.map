{"version":3,"sources":["constants/card-constants.ts","Card.tsx","utilities/geo.ts","ContextMenu.tsx","App.tsx","features/cards/initialState.ts","features/cards/cards.slice.ts","features/cards-data/cards-data.slice.ts","features/cards-data/initialState.ts","features/cards/cards.selectors.ts","features/cards-data/cards-data.selectors.ts","AppContainer.tsx","serviceWorker.ts","store/rootReducer.ts","store/configureStore.ts","index.tsx"],"names":["cardConstants","Card","props","img","unmounted","handleContextMenu","event","id","handleDoubleClick","handleDragStart","handleDragMove","dx","target","x","dy","y","handleDragEnd","dragging","handleClick","cancelBubble","handleMouseDown","handleMouseOver","handleHover","handleMouseOut","handleHoverLeave","state","imageLoaded","prevImgUrl","imgUrl","Image","onload","setState","src","prevProps","prevState","this","renderCard","heightToUse","height","widthToUse","width","native","to","rotation","exhausted","animatedProps","Rect","cornerRadius","offset","stroke","dropTarget","strokeWidth","fillPatternImage","fillPatternScaleX","naturalWidth","fillPatternScaleY","naturalHeight","shadowBlur","selected","opacity","isGhost","draggable","onDragStart","onDragMove","onDragEnd","onDblClick","onDblTap","onClick","onTap","onMouseDown","onTouchStart","onMouseOver","onMouseOut","onContextMenu","Component","getDistance","point1","point2","deltaX","deltaY","Math","sqrt","ContextMenu","preventDefault","handleContextItemClicked","contextItemClicked","menuStyle","top","position","left","className","style","items","map","i","index","App","stage","renderContextMenu","showContextMenu","containerRect","container","getBoundingClientRect","pointerPosition","contextMenuPosition","Error","contextMenuItems","clearContextMenu","handleCardContextMenu","cardId","evt","card","cards","find","c","menuItems","cardStack","length","console","log","push","getPointerPosition","handleCardDragStart","splitTopCard","filter","draggingCard","hasStack","upperRightPoint","getRelativePositionFromTarget","startCardMove","handleKeyPress","code","which","keyCode","togglePanMode","flipCards","getRawPreviewCardPosition","pointerPos","screenMidPointX","window","innerWidth","posParam","transform","getAbsoluteTransform","copy","invert","pos","point","currentTarget","selectStartPos","selecting","getSelectionRectInfo","selectRect","abs","handleMouseUp","drewASelectionRect","selectedCards","reduce","currSelectedCards","Intersects","selectMultipleCards","ids","handleMouseMove","getImgUrl","Object","keys","cardsData","cardData","jsonId","faceup","back_link","process","octgn_id","loadCardsData","staticCards","fill","dropTargetCard","cardMove","endCardMove","exhaustCard","selectCard","hoverCard","hoverLeaveCard","numCardsInStack","ghostCards","movingCards","previewCards","showPreview","previewCard","rawPos","previewPos","tabIndex","onKeyPress","ref","innerHeight","unselectAllCards","panMode","onMouseUp","onMouseMove","onTouchMove","concat","initialState","uuidv4","getCardStackWithId","cardsSlice","createSlice","name","reducers","action","callback","cardToUpdate","mutateCardWithId","payload","forEach","cardToStartMoving","cardToMove","topCard","shift","newCard","assign","foreachSelectedCard","primaryCard","movedCards","possibleDropTargets","foreachUnselectedCard","distance","sort","c1","c2","movedCard","splice","indexOf","dropTargetCards","cardToPreview","actions","cardsDataSlice","entities","CoreData","error","getCards","shouldShowPreview","createSelector","every","getPanMode","getCardsDataEntities","AppContainer","connect","Boolean","location","hostname","match","rootReducer","combineReducers","customizedMiddleware","getDefaultMiddleware","thunk","store","rtkConfigureStore","reducer","middleware","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.b54b7aa9.chunk.js","sourcesContent":["export const cardConstants = {\n  CARD_HEIGHT: 209,\n  CARD_WIDTH: 150,\n  CARD_PREVIEW_HEIGHT: 418,\n  CARD_PREVIEW_WIDTH: 300,\n};\n","// tslint:disable:no-console\nimport { KonvaEventObject } from \"konva/types/Node\";\nimport * as React from \"react\";\nimport { Component } from \"react\";\nimport { animated, Spring } from \"react-spring/renderprops-konva\";\nimport { cardConstants } from \"./constants/card-constants\";\n// import Portal from './Portal';\n// import ContextMenu from './ContextMenu';\n\ninterface IProps {\n  dragging: boolean;\n  exhausted: boolean;\n  fill: string;\n  handleClick?: (id: string) => void;\n  handleDoubleClick?: (id: string) => void;\n  handleDragStart?: (id: string, event: MouseEvent) => void;\n  handleDragMove?: (info: { id: string; dx: number; dy: number }) => void;\n  handleDragEnd?: (id: string) => void;\n  handleHover?: (id: string) => void;\n  handleHoverLeave?: (id: string) => void;\n  id: string;\n  selected: boolean;\n  dropTarget?: boolean;\n  x: number;\n  y: number;\n  width?: number;\n  height?: number;\n  imgUrl: string;\n  isGhost?: boolean;\n  numCardsInStack?: number;\n  handleContextMenu?: (\n    id: string,\n    event: KonvaEventObject<PointerEvent>\n  ) => void;\n}\n\ninterface IState {\n  imageLoaded: boolean;\n  prevImgUrl: string;\n}\n\nclass Card extends Component<IProps, IState> {\n  // tslint:disable-next-line:member-access\n  static getDerivedStateFromProps(props: IProps, state: IState): IState | null {\n    if (props.imgUrl !== state.prevImgUrl) {\n      return {\n        imageLoaded: false,\n        prevImgUrl: props.imgUrl,\n      };\n    }\n    // No state update necessary\n    return null;\n  }\n\n  private img: HTMLImageElement;\n  private unmounted: boolean;\n\n  constructor(props: IProps) {\n    super(props);\n\n    this.unmounted = true;\n\n    this.state = {\n      imageLoaded: false,\n      prevImgUrl: this.props.imgUrl,\n    };\n\n    this.img = new Image();\n\n    // When the image loads, set a flag in the state\n    this.img.onload = () => {\n      if (!this.unmounted) {\n        this.setState({\n          imageLoaded: true,\n        });\n      }\n    };\n\n    if (props.imgUrl) {\n      this.img.src = props.imgUrl;\n    }\n  }\n\n  public componentDidUpdate(prevProps: IProps, prevState: IState) {\n    if (\n      !this.state.imageLoaded &&\n      this.props.imgUrl &&\n      this.props.imgUrl !== this.img.src\n    ) {\n      this.img.src = this.props.imgUrl;\n    }\n  }\n\n  public componentDidMount() {\n    this.unmounted = false;\n  }\n\n  public componentWillUnmount() {\n    this.unmounted = true;\n  }\n\n  public render() {\n    return this.state.imageLoaded ? this.renderCard() : null;\n  }\n\n  private renderContext() {\n    // return this.state.showContextMenu ? (\n    //   <Portal key={`${this.props.id}-context`}>\n    //     <div>HI THERE</div>\n    //   </Portal>\n    // ) : null;\n  }\n\n  private renderCard() {\n    const heightToUse = this.props.height || cardConstants.CARD_HEIGHT;\n    const widthToUse = this.props.width || cardConstants.CARD_WIDTH;\n\n    return (\n      <Spring\n        key={`${this.props.id}-card`}\n        native={true}\n        to={{\n          rotation: this.props.exhausted ? 90 : 0,\n        }}\n      >\n        {(animatedProps: any) => (\n          <animated.Rect\n            {...animatedProps}\n            cornerRadius={9}\n            x={this.props.x}\n            y={this.props.y}\n            width={widthToUse}\n            height={heightToUse}\n            offset={{\n              x: widthToUse / 2,\n              y: heightToUse / 2,\n            }}\n            stroke={this.props.dropTarget ? \"blue\" : \"\"}\n            strokeWidth={this.props.dropTarget ? 2 : 0}\n            fillPatternImage={this.img}\n            fillPatternScaleX={\n              this.state.imageLoaded\n                ? widthToUse / this.img.naturalWidth\n                : widthToUse\n            }\n            fillPatternScaleY={\n              this.state.imageLoaded\n                ? heightToUse / this.img.naturalHeight\n                : heightToUse\n            }\n            shadowBlur={this.props.dragging ? 10 : this.props.selected ? 5 : 0}\n            opacity={this.props.isGhost ? 0.5 : 1}\n            draggable={true}\n            onDragStart={this.handleDragStart}\n            onDragMove={this.handleDragMove}\n            onDragEnd={this.handleDragEnd}\n            onDblClick={this.handleDoubleClick}\n            onDblTap={this.handleDoubleClick}\n            onClick={this.handleClick}\n            onTap={this.handleClick}\n            onMouseDown={this.handleMouseDown}\n            onTouchStart={this.handleMouseDown}\n            onMouseOver={this.handleMouseOver}\n            onMouseOut={this.handleMouseOut}\n            onContextMenu={this.handleContextMenu}\n          />\n        )}\n      </Spring>\n    );\n  }\n\n  private handleContextMenu = (event: KonvaEventObject<PointerEvent>): void => {\n    if (!!this.props.handleContextMenu) {\n      this.props.handleContextMenu(this.props.id, event);\n    }\n    // console.log('Context Menu in Card!');\n    // event.evt.preventDefault();\n    // event.cancelBubble = true;\n    // if (!!this.props.numCardsInStack && this.props.numCardsInStack > 1) {\n    //   console.log('Can shuffle!');\n    // } else {\n    //   console.log('Can\\'t shuffle!');\n    // }\n  };\n\n  private handleDoubleClick = () => {\n    if (this.props.handleDoubleClick) {\n      this.props.handleDoubleClick(this.props.id);\n    }\n  };\n\n  private handleDragStart = (event: MouseEvent) => {\n    if (this.props.handleDragStart) {\n      this.props.handleDragStart(this.props.id, event);\n    }\n  };\n\n  private handleDragMove = (event: any) => {\n    if (this.props.handleDragMove) {\n      this.props.handleDragMove({\n        id: this.props.id,\n        dx: event.target.x() - this.props.x,\n        dy: event.target.y() - this.props.y,\n      });\n    }\n  };\n\n  private handleDragEnd = () => {\n    if (this.props.handleDragEnd && this.props.dragging) {\n      this.props.handleDragEnd(this.props.id);\n    }\n  };\n\n  private handleClick = (event: any) => {\n    if (this.props.handleClick) {\n      this.props.handleClick(this.props.id);\n      event.cancelBubble = true;\n    }\n  };\n\n  private handleMouseDown = (event: any) => {\n    event.cancelBubble = true;\n  };\n\n  private handleMouseOver = () => {\n    if (this.props.handleHover) {\n      this.props.handleHover(this.props.id);\n    }\n  };\n\n  private handleMouseOut = () => {\n    if (this.props.handleHoverLeave) {\n      this.props.handleHoverLeave(this.props.id);\n    }\n  };\n}\n\nexport default Card;\n","import { Vector2d } from \"konva/types/types\";\n\nexport const getDistance = (point1: Vector2d, point2: Vector2d): number => {\n  const deltaX = point1.x - point2.x;\n  const deltaY = point1.y - point2.y;\n  return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n};\n","import { Vector2d } from \"konva/types/types\";\nimport * as React from \"react\";\nimport { Component } from \"react\";\n\nexport type ContextMenuItem = string;\n\ninterface IProps {\n  position: Vector2d;\n  items: ContextMenuItem[];\n  contextItemClicked?: (item: ContextMenuItem) => void;\n}\n\nclass ContextMenu extends Component<IProps> {\n  render() {\n    const menuStyle: React.CSSProperties = {\n      top: `${this.props.position.y + 8}px`,\n      left: `${this.props.position.x + 8}px`,\n    };\n\n    return (\n      <div\n        id=\"context-menu-layer\"\n        onClick={this.handleContextItemClicked}\n        onContextMenu={this.preventDefault}\n      >\n        <div\n          className=\"context-menu\"\n          style={menuStyle}\n          onContextMenu={this.preventDefault}\n        >\n          {this.props.items.map((i, index) => (\n            <div\n              key={`context-menu-item-${index}`}\n              className=\"context-menu-item\"\n            >\n              {i}\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  }\n\n  private preventDefault = (\n    event: React.MouseEvent<HTMLDivElement, MouseEvent>\n  ) => {\n    event.preventDefault();\n  };\n\n  private handleContextItemClicked = () => {\n    if (!!this.props.contextItemClicked) {\n      this.props.contextItemClicked(\"dummy\");\n    }\n  };\n}\n\nexport default ContextMenu;\n","import * as Intersects from \"intersects\";\nimport { Component } from \"react\";\nimport * as React from \"react\";\nimport { Layer, Rect, Stage } from \"react-konva\";\nimport Konva from \"konva\";\nimport { cardConstants } from \"./constants/card-constants\";\nimport \"./App.scss\";\nimport Card from \"./Card\";\nimport { ICardStack, ICardsState } from \"./features/cards/initialState\";\nimport { Vector2d } from \"konva/types/types\";\nimport { getDistance } from \"./utilities/geo\";\nimport { ICardData } from \"./features/cards-data/initialState\";\nimport { KonvaEventObject } from \"konva/types/Node\";\nimport ContextMenu from \"./ContextMenu\";\n\ninterface IProps {\n  cards: ICardsState;\n  cardsData: ICardData;\n  showPreview: boolean;\n  panMode: boolean;\n  cardMove: (info: { id: string; dx: number; dy: number }) => void;\n  endCardMove: (id: string) => void;\n  exhaustCard: (id: string) => void;\n  selectCard: (id: string) => void;\n  startCardMove: (payload: { id: string; splitTopCard: boolean }) => void;\n  unselectAllCards: () => void;\n  selectMultipleCards: (cards: { ids: string[] }) => void;\n  hoverCard: (id: string) => void;\n  hoverLeaveCard: (id: string) => void;\n  togglePanMode: () => void;\n  flipCards: () => void;\n  loadCardsData: () => void;\n}\n\ninterface IState {\n  drewASelectionRect: boolean;\n  selectRect: {\n    height: number;\n    width: number;\n  };\n  selectStartPos: {\n    x: number;\n    y: number;\n  };\n  selecting: boolean;\n  showContextMenu: boolean;\n  contextMenuPosition: Vector2d | null;\n  contextMenuItems: string[];\n}\nclass App extends Component<IProps, IState> {\n  public stage: Konva.Stage | null = null;\n\n  constructor(props: IProps) {\n    super(props);\n\n    this.state = {\n      drewASelectionRect: false,\n      selectRect: {\n        height: 0,\n        width: 0,\n      },\n      selectStartPos: {\n        x: 0,\n        y: 0,\n      },\n      selecting: false,\n      showContextMenu: false,\n      contextMenuPosition: null,\n      contextMenuItems: [],\n    };\n  }\n\n  public componentDidMount() {\n    this.props.loadCardsData();\n  }\n\n  public render() {\n    const staticCards = this.props.cards.cards\n      .filter((card) => !card.dragging)\n      .map((card) => {\n        return (\n          <Card\n            key={card.id}\n            id={card.id}\n            x={card.x}\n            y={card.y}\n            exhausted={card.exhausted}\n            fill={card.fill}\n            selected={card.selected}\n            dropTarget={card.id === this.props.cards.dropTargetCard?.id}\n            dragging={card.dragging}\n            handleDragStart={this.handleCardDragStart}\n            handleDragMove={this.props.cardMove}\n            handleDragEnd={this.props.endCardMove}\n            handleDoubleClick={this.props.exhaustCard}\n            handleClick={this.props.selectCard}\n            handleHover={this.props.hoverCard}\n            handleHoverLeave={this.props.hoverLeaveCard}\n            handleContextMenu={this.handleCardContextMenu}\n            imgUrl={this.getImgUrl(card)}\n            numCardsInStack={card.cardStack.length}\n          />\n        );\n      });\n\n    const ghostCards = this.props.cards.ghostCards.map((card) => {\n      return (\n        <Card\n          key={`ghost${card.id}`}\n          id={card.id}\n          x={card.x}\n          y={card.y}\n          exhausted={card.exhausted}\n          fill={card.fill}\n          selected={false}\n          dragging={false}\n          imgUrl={this.getImgUrl(card)}\n          isGhost={true}\n        />\n      );\n    });\n\n    const movingCards = this.props.cards.cards\n      .filter((card) => card.dragging)\n      .map((card) => {\n        return (\n          <Card\n            key={card.id}\n            id={card.id}\n            x={card.x}\n            y={card.y}\n            exhausted={card.exhausted}\n            fill={card.fill}\n            selected={card.selected}\n            dragging={card.dragging}\n            handleDragStart={this.handleCardDragStart}\n            handleDragMove={this.props.cardMove}\n            handleDragEnd={this.props.endCardMove}\n            handleDoubleClick={this.props.exhaustCard}\n            handleClick={this.props.selectCard}\n            imgUrl={this.getImgUrl(card)}\n          />\n        );\n      });\n\n    const previewCards = this.props.cards.cards\n      .filter(\n        (card) =>\n          !this.state.selecting &&\n          this.props.showPreview &&\n          !!this.props.cards.previewCard &&\n          card.id === this.props.cards.previewCard.id\n      )\n      .map((card) => {\n        const rawPos = this.getRawPreviewCardPosition();\n        const previewPos = this.getRelativePositionFromTarget(\n          this.stage,\n          rawPos\n        );\n        return (\n          <Card\n            key={`preview${card.id}`}\n            id={card.id}\n            x={previewPos.x}\n            y={previewPos.y}\n            exhausted={false}\n            fill={card.fill}\n            selected={false}\n            dragging={false}\n            imgUrl={this.getImgUrl(card)}\n            height={cardConstants.CARD_PREVIEW_HEIGHT}\n            width={cardConstants.CARD_PREVIEW_WIDTH}\n          />\n        );\n      });\n\n    return (\n      <div tabIndex={1} onKeyPress={this.handleKeyPress}>\n        {this.renderContextMenu()}\n        <Stage\n          ref={(ref) => {\n            this.stage = ref;\n          }}\n          width={window.innerWidth}\n          height={window.innerHeight}\n          onClick={() => this.props.unselectAllCards()}\n          onTap={() => this.props.unselectAllCards()}\n          onMouseDown={this.props.panMode ? () => {} : this.handleMouseDown}\n          onMouseUp={this.props.panMode ? () => {} : this.handleMouseUp}\n          onMouseMove={this.props.panMode ? () => {} : this.handleMouseMove}\n          onTouchMove={this.props.panMode ? () => {} : this.handleMouseMove}\n          onContextMenu={this.handleContextMenu}\n          draggable={this.props.panMode}\n          // // tslint:disable-next-line:jsx-no-lambda no-console\n          // onDragStart={() => {console.log('STAGE onDragStart')}}\n          // // tslint:disable-next-line:jsx-no-lambda no-console\n          // onDragMove={() => {console.log('STAGE onDragMove')}}\n          // // tslint:disable-next-line:jsx-no-lambda no-console\n          // onDragEnd={() => {console.log('STAGE onDragEnd')}}\n          preventDefault={true}\n        >\n          <Layer preventDefault={true}>\n            {staticCards\n              .concat(ghostCards)\n              .concat(movingCards)\n              .concat(previewCards)}\n          </Layer>\n          <Layer>\n            <Rect\n              x={this.state.selectStartPos.x}\n              y={this.state.selectStartPos.y}\n              width={this.state.selectRect.width}\n              height={this.state.selectRect.height}\n              stroke=\"black\"\n            />\n          </Layer>\n        </Stage>\n      </div>\n    );\n  }\n\n  private renderContextMenu = () => {\n    if (!this.state.showContextMenu) return null;\n\n    const containerRect = this.stage?.container().getBoundingClientRect();\n    const pointerPosition = this.state.contextMenuPosition;\n    if (!containerRect || !pointerPosition) {\n      throw new Error(\"Problem computing context menu position\");\n    }\n\n    return this.state.showContextMenu ? (\n      <ContextMenu\n        position={{\n          x: containerRect.left + pointerPosition.x,\n          y: containerRect.top + pointerPosition.y,\n        }}\n        items={this.state.contextMenuItems}\n        contextItemClicked={() => this.clearContextMenu()}\n      ></ContextMenu>\n    ) : null;\n  };\n\n  private clearContextMenu = () => {\n    this.setState({\n      showContextMenu: false,\n      contextMenuPosition: null,\n      contextMenuItems: [],\n    });\n  };\n\n  private handleCardContextMenu = (\n    cardId: string,\n    event: KonvaEventObject<PointerEvent>\n  ) => {\n    event.evt.preventDefault();\n    event.cancelBubble = true;\n\n    const card = this.props.cards.cards.find((c) => c.id === cardId);\n    const numCardsInStack = card?.cardStack?.length || 0;\n\n    const menuItems = [\"Flip\"];\n\n    if (numCardsInStack > 1) {\n      console.log(\"Can shuffle\");\n      menuItems.push(\"Shuffle\");\n    } else {\n      console.log(\"Cannot shuffle\");\n    }\n\n    this.setState({\n      showContextMenu: true,\n      contextMenuPosition: this.stage?.getPointerPosition() ?? null,\n      contextMenuItems: menuItems,\n    });\n  };\n\n  private handleCardDragStart = (cardId: string, event: MouseEvent) => {\n    let splitTopCard = false;\n    // If multiple things are selected, you can't pull something off the top of a stack,\n    // so just do a normal drag\n    const multipleSelected =\n      this.props.cards.cards.filter((c) => c.selected).length > 1;\n\n    if (!multipleSelected) {\n      const draggingCard = this.props.cards.cards.find((c) => c.id === cardId);\n      const hasStack = (draggingCard?.cardStack || []).length > 1;\n      if (!!draggingCard && hasStack) {\n        // Check if we're dragging in the upper right corner of the card\n        const upperRightPoint = {\n          x: draggingCard.x + cardConstants.CARD_WIDTH / 2,\n          y: draggingCard.y - cardConstants.CARD_HEIGHT / 2,\n        };\n        const distance = getDistance(\n          upperRightPoint,\n          this.getRelativePositionFromTarget(this.stage)\n        );\n        if (distance < 30) {\n          splitTopCard = true;\n        }\n      }\n    }\n\n    this.props.startCardMove({ id: cardId, splitTopCard });\n  };\n\n  private handleKeyPress = (event: any) => {\n    const code = event.which || event.keyCode;\n    if (code === 115) {\n      this.props.togglePanMode();\n    } else if (code === 102) {\n      this.props.flipCards();\n    }\n  };\n\n  private getRawPreviewCardPosition = (): Vector2d => {\n    const pointerPos = this.stage?.getPointerPosition() ?? { x: 0, y: 0 };\n    const screenMidPointX = window.innerWidth / 2;\n    return pointerPos.x < screenMidPointX\n      ? {\n          x: window.innerWidth - cardConstants.CARD_PREVIEW_WIDTH / 2,\n          y: cardConstants.CARD_PREVIEW_HEIGHT / 2,\n        }\n      : {\n          x: cardConstants.CARD_PREVIEW_WIDTH / 2,\n          y: cardConstants.CARD_PREVIEW_HEIGHT / 2,\n        };\n  };\n\n  private getRelativePositionFromTarget = (\n    target: any,\n    posParam?: Vector2d\n  ) => {\n    const transform = target.getAbsoluteTransform().copy();\n    transform.invert();\n    let pos = posParam || target.getPointerPosition();\n    return transform.point(pos);\n  };\n\n  private handleMouseDown = (event: any) => {\n    const pos = this.getRelativePositionFromTarget(event.currentTarget);\n\n    this.setState({\n      selectStartPos: {\n        x: pos.x,\n        y: pos.y,\n      },\n      selecting: true,\n    });\n  };\n\n  private getSelectionRectInfo = () => {\n    const selectStartPos = this.state.selectStartPos;\n    const selectRect = this.state.selectRect;\n    return {\n      height: Math.abs(selectRect.height),\n      width: Math.abs(selectRect.width),\n      x:\n        selectRect.width < 0\n          ? selectStartPos.x + selectRect.width\n          : selectStartPos.x,\n      y:\n        selectRect.height < 0\n          ? selectStartPos.y + selectRect.height\n          : selectStartPos.y,\n    };\n  };\n\n  private handleMouseUp = () => {\n    // if we were selecting, check for intersection\n    if (this.state.drewASelectionRect) {\n      const selectRect = this.getSelectionRectInfo();\n      const selectedCards: any[] = this.props.cards.cards.reduce<ICardStack[]>(\n        (currSelectedCards, card) => {\n          const intersects = Intersects.boxBox(\n            selectRect.x,\n            selectRect.y,\n            selectRect.width,\n            selectRect.height,\n            card.x - 50,\n            card.y - 75,\n            cardConstants.CARD_WIDTH,\n            cardConstants.CARD_HEIGHT\n          );\n\n          if (intersects) {\n            currSelectedCards.push(card);\n          }\n\n          return currSelectedCards;\n        },\n        []\n      );\n\n      this.props.selectMultipleCards({\n        ids: selectedCards.map((card) => card.id),\n      });\n    }\n\n    this.setState({\n      drewASelectionRect: false,\n      selectRect: {\n        height: 0,\n        width: 0,\n      },\n      selectStartPos: {\n        x: 0,\n        y: 0,\n      },\n      selecting: false,\n    });\n  };\n\n  private handleMouseMove = (event: any) => {\n    if (this.state.selecting) {\n      const pos = this.getRelativePositionFromTarget(event.currentTarget);\n      this.setState({\n        drewASelectionRect: true,\n        selectRect: {\n          height: pos.y - this.state.selectStartPos.y,\n          width: pos.x - this.state.selectStartPos.x,\n        },\n      });\n    }\n    event.cancelBubble = true;\n  };\n\n  private handleContextMenu = (event: KonvaEventObject<PointerEvent>): void => {\n    event.evt.preventDefault();\n    event.cancelBubble = true;\n\n    const menuItems = [\"Load Deck ID\", \"Load Encounter\"];\n\n    this.setState({\n      showContextMenu: true,\n      contextMenuPosition: this.stage?.getPointerPosition() ?? null,\n      contextMenuItems: menuItems,\n    });\n  };\n\n  private getImgUrl = (card: ICardStack): string => {\n    if (Object.keys(this.props.cardsData).length === 0) return \"\";\n\n    const cardData = this.props.cardsData[card.cardStack[0].jsonId];\n\n    if (!card.faceup && !!cardData.back_link) {\n      return (\n        process.env.PUBLIC_URL + \"/images/cards/\" + cardData.octgn_id + \".b.jpg\"\n      );\n    } else if (!card.faceup) {\n      return process.env.PUBLIC_URL + \"/images/standard/card_back.png\";\n    }\n\n    return (\n      process.env.PUBLIC_URL + \"/images/cards/\" + cardData.octgn_id + \".jpg\"\n    );\n  };\n}\n\nexport default App;\n","import { v4 as uuidv4 } from \"uuid\";\nexport interface ICardStack {\n  dragging: boolean;\n  exhausted: boolean;\n  faceup: boolean;\n  fill: string;\n  id: string;\n  selected: boolean;\n  x: number;\n  y: number;\n  cardStack: ICardDetails[];\n}\n\nexport interface ICardDetails {\n  jsonId: string;\n}\n\nexport interface IPreviewCard {\n  id: string;\n}\n\nexport interface ICardsState {\n  cards: ICardStack[];\n  ghostCards: ICardStack[];\n  previewCard: IPreviewCard | null;\n  dropTargetCard: ICardStack | null;\n  panMode: boolean;\n}\n\nexport const initialState: ICardsState = {\n  cards: [\n    {\n      dragging: false,\n      exhausted: false,\n      faceup: true,\n      fill: \"red\",\n      id: uuidv4(),\n      selected: false,\n      x: 200,\n      y: 200,\n      cardStack: [{ jsonId: \"01001a\" }],\n    },\n    {\n      dragging: false,\n      exhausted: false,\n      faceup: true,\n      fill: \"red\",\n      id: uuidv4(),\n      selected: false,\n      x: 400,\n      y: 400,\n      cardStack: [{ jsonId: \"01027\" }],\n    },\n    {\n      dragging: false,\n      exhausted: false,\n      faceup: true,\n      fill: \"red\",\n      id: uuidv4(),\n      selected: false,\n      x: 200,\n      y: 600,\n      cardStack: [{ jsonId: \"01036\" }],\n    },\n  ],\n  ghostCards: [],\n  previewCard: null,\n  dropTargetCard: null,\n  panMode: true,\n};\n","import { createSlice, PayloadAction, CaseReducer } from \"@reduxjs/toolkit\";\nimport { getDistance } from \"../../utilities/geo\";\nimport {\n  initialState,\n  ICardsState,\n  ICardStack,\n  ICardDetails,\n} from \"./initialState\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nconst CARD_DROP_TARGET_DISTANCE = 30;\n\n// Helper methods\nconst getCardStackWithId = (\n  state: ICardsState,\n  id: string\n): ICardStack | undefined => {\n  return state.cards.find((card) => card.id === id);\n};\n\nconst mutateCardWithId = (\n  state: ICardsState,\n  id: string,\n  callback: (card: ICardStack) => void\n) => {\n  const cardToUpdate = getCardStackWithId(state, id);\n  if (cardToUpdate) {\n    callback(cardToUpdate);\n  }\n};\n\nconst foreachSelectedCard = (\n  state: ICardsState,\n  callback: (card: ICardStack) => void\n) => {\n  state.cards.filter((card) => card.selected).forEach((card) => callback(card));\n};\n\nconst foreachUnselectedCard = (\n  state: ICardsState,\n  callback: (card: ICardStack) => void\n) => {\n  state.cards\n    .filter((card) => !card.selected)\n    .forEach((card) => callback(card));\n};\n\n// Reducers\nconst selectCardReducer: CaseReducer<ICardsState, PayloadAction<string>> = (\n  state,\n  action\n) => {\n  mutateCardWithId(state, action.payload, (card) => {\n    card.selected = !card.selected;\n  });\n};\n\nconst exhaustCardReducer: CaseReducer<ICardsState, PayloadAction<string>> = (\n  state,\n  action\n) => {\n  state.cards\n    .filter((card) => card.id === action.payload || card.selected)\n    .forEach((card) => {\n      card.exhausted = !card.exhausted;\n    });\n};\n\nconst startCardMoveReducer: CaseReducer<\n  ICardsState,\n  PayloadAction<{ id: string; splitTopCard: boolean }>\n> = (state, action) => {\n  // first, if the card moving isn't currently selected, clear all selected cards\n  const cardToStartMoving = getCardStackWithId(state, action.payload.id);\n  if (cardToStartMoving && !cardToStartMoving.selected) {\n    state.cards = state.cards.map((card) => {\n      card.selected = card.id === action.payload.id;\n      return card;\n    });\n  }\n\n  // If we are splitting, make a new stack of cards\n  if (action.payload.splitTopCard) {\n    const cardToMove = state.cards.find((c) => c.id === action.payload.id);\n\n    if (!cardToMove) {\n      throw new Error(\"Expected to find card\");\n    }\n\n    cardToMove.selected = false;\n\n    const topCard = cardToMove.cardStack.shift();\n    const newCard = Object.assign({}, cardToMove, {\n      cardStack: [topCard],\n    });\n\n    cardToMove.id = uuidv4();\n\n    state.cards.push(newCard);\n  }\n\n  // Now all selected cards should be put into ghost cards, unless we are splitting the top card\n  state.ghostCards = [];\n\n  if (!action.payload.splitTopCard) {\n    foreachSelectedCard(state, (card) => {\n      card.dragging = true;\n      state.ghostCards.push(Object.assign({}, card));\n    });\n  }\n};\n\nconst cardMoveReducer: CaseReducer<\n  ICardsState,\n  PayloadAction<{ id: string; dx: number; dy: number }>\n> = (state, action) => {\n  const movedCards: ICardStack[] = [];\n\n  let primaryCard: ICardStack;\n\n  state.cards\n    .filter((card) => card.id === action.payload.id || card.selected)\n    .forEach((card) => {\n      if (card.id === action.payload.id) {\n        primaryCard = card;\n      }\n\n      card.x += action.payload.dx;\n      card.y += action.payload.dy;\n\n      movedCards.push(card);\n    });\n\n  // go through and find if any unselected cards are potential drop targets\n  // If so, get the closest one\n  const possibleDropTargets: { distance: number; card: ICardStack }[] = [];\n  foreachUnselectedCard(state, (card) => {\n    const distance = getDistance(card, primaryCard);\n    if (distance < CARD_DROP_TARGET_DISTANCE) {\n      possibleDropTargets.push({\n        distance,\n        card,\n      });\n    }\n  });\n\n  state.dropTargetCard =\n    possibleDropTargets.sort((c1, c2) => c1.distance - c2.distance)[0]?.card ??\n    null;\n\n  // put the moved cards at the end. TODO: we could just store the move order or move time\n  // or something, and the array could be a selector\n  movedCards.forEach((movedCard) => {\n    state.cards.push(state.cards.splice(state.cards.indexOf(movedCard), 1)[0]);\n  });\n};\n\nconst endCardMoveReducer: CaseReducer<ICardsState, PayloadAction<string>> = (\n  state,\n  action\n) => {\n  let dropTargetCards: ICardDetails[] = [];\n  state.cards\n    .filter((card) => card.id === action.payload || card.selected)\n    .forEach((card) => {\n      card.dragging = false;\n\n      if (!!state.dropTargetCard) {\n        // Add the cards to the drop Target card stack\n        dropTargetCards = dropTargetCards.concat(card.cardStack);\n      }\n    });\n\n  // Now, if there was a drop target card, remove all those cards from the state\n  if (!!state.dropTargetCard) {\n    state.cards = state.cards.filter(\n      (card) => !(card.id === action.payload || card.selected)\n    );\n\n    const dropTargetCard = state.cards.find(\n      (card) => card.id === state.dropTargetCard?.id\n    );\n    if (!!dropTargetCard && dropTargetCards.length > 0) {\n      // add the cards we've collected to the top of the stack\n      dropTargetCard.cardStack = dropTargetCards.concat(\n        dropTargetCard.cardStack\n      );\n    }\n  }\n\n  state.ghostCards = [];\n  state.dropTargetCard = null;\n};\n\nconst selectMultipleCardsReducer: CaseReducer<\n  ICardsState,\n  PayloadAction<{ ids: string[] }>\n> = (state, action) => {\n  action.payload.ids\n    .map((id) => state.cards.find((card) => card.id === id))\n    .forEach((card) => {\n      if (card) {\n        card.selected = true;\n      }\n    });\n};\n\nconst unselectAllCardsReducer: CaseReducer<ICardsState> = (state) => {\n  state.cards.forEach((card) => {\n    card.selected = false;\n  });\n};\n\nconst hoverCardReducer: CaseReducer<ICardsState, PayloadAction<string>> = (\n  state,\n  action\n) => {\n  const cardToPreview = state.cards.find((c) => c.id === action.payload);\n  if (!cardToPreview?.faceup) return;\n\n  if (state.previewCard === null) {\n    state.previewCard = {\n      id: action.payload,\n    };\n  } else if (action.payload !== state.previewCard.id) {\n    state.previewCard.id = action.payload;\n  }\n};\n\nconst hoverLeaveCardReducer: CaseReducer<ICardsState> = (state) => {\n  if (state.previewCard !== null) {\n    state.previewCard = null;\n  }\n};\n\nconst togglePanModeReducer: CaseReducer<ICardsState> = (state) => {\n  state.panMode = !state.panMode;\n};\n\nconst flipCardsReducer: CaseReducer<ICardsState> = (state, action) => {\n  state.cards\n    .filter((card) => card.selected)\n    .forEach((card) => {\n      card.faceup = !card.faceup;\n    });\n};\n// Selectors\n\n// slice\n\nconst cardsSlice = createSlice({\n  name: \"cards\",\n  initialState: initialState,\n  reducers: {\n    selectCard: selectCardReducer,\n    exhaustCard: exhaustCardReducer,\n    startCardMove: startCardMoveReducer,\n    cardMove: cardMoveReducer,\n    endCardMove: endCardMoveReducer,\n    selectMultipleCards: selectMultipleCardsReducer,\n    unselectAllCards: unselectAllCardsReducer,\n    hoverCard: hoverCardReducer,\n    hoverLeaveCard: hoverLeaveCardReducer,\n    togglePanMode: togglePanModeReducer,\n    flipCards: flipCardsReducer,\n  },\n});\n\nexport const {\n  selectCard,\n  exhaustCard,\n  startCardMove,\n  cardMove,\n  endCardMove,\n  selectMultipleCards,\n  unselectAllCards,\n  hoverCard,\n  hoverLeaveCard,\n  togglePanMode,\n  flipCards,\n} = cardsSlice.actions;\n\nexport default cardsSlice.reducer;\n","import { createSlice, CaseReducer } from \"@reduxjs/toolkit\";\nimport { initialState, ICardsDataState } from \"./initialState\";\n\nimport CoreData from \"../../external/marvelsdb-json-data/pack/core.json\";\n\n// Reducers\nconst loadCardsDataReducer: CaseReducer<ICardsDataState> = (state) => {\n  //This reducer is only intended to be called a single time each load.\n  CoreData.forEach((card) => {\n    if (state.entities[card.code]) {\n      console.error(\"Found multiple cards with code \" + card.code);\n    }\n\n    state.entities[card.code] = card;\n  });\n  return state;\n};\n\n// slice\nconst cardsDataSlice = createSlice({\n  name: \"cardsData\",\n  initialState: initialState,\n  reducers: {\n    loadCardsData: loadCardsDataReducer,\n  },\n});\n\nexport const { loadCardsData } = cardsDataSlice.actions;\n\nexport default cardsDataSlice.reducer;\n","import { CardData } from \"../../external-api/marvel-card-data\";\n\nexport interface ICardData {\n  [key: string]: CardData;\n}\n\nexport interface ICardsDataState {\n  entities: ICardData;\n}\n\nexport const initialState: ICardsDataState = {\n  entities: {},\n};\n","import { createSelector } from \"@reduxjs/toolkit\";\nimport { RootState } from \"../../store/rootReducer\";\n\nexport const getCards = (state: RootState) => state.cards;\n\nexport const shouldShowPreview = createSelector(getCards, (cards) => {\n  return !!cards.previewCard && cards.cards.every((card) => !card.dragging);\n});\n\nexport const getPanMode = (state: RootState) => state.cards.panMode;\n","import { createSelector } from \"@reduxjs/toolkit\";\nimport { RootState } from \"../../store/rootReducer\";\n\nexport const getCardsData = (state: RootState) => state.cardsData;\n\nexport const getCardsDataEntities = createSelector(\n  getCardsData,\n  (cardsData) => {\n    return cardsData.entities;\n  }\n);\n","import { connect } from \"react-redux\";\n// import Types from 'Types';\nimport App from \"./App\";\nimport {\n  selectCard,\n  exhaustCard,\n  startCardMove,\n  cardMove,\n  endCardMove,\n  selectMultipleCards,\n  unselectAllCards,\n  hoverCard,\n  hoverLeaveCard,\n  togglePanMode,\n  flipCards,\n} from \"./features/cards/cards.slice\";\nimport { loadCardsData } from \"./features/cards-data/cards-data.slice\";\n// import * as cardActions from './features/cards/actions';\n// import { shouldShowPreview } from './features/cards/selectors';\n// import { get3RandomPlayerCardDatas } from './features/cardsData/selectors';\n// import * as cardThunks from './features/cardsData/thunks';\n// import * as CoreSet from './external/ringsteki-json-data/packs/Core Set.json';\n// import CoreSet from './external/marvelsdb-json-data/pack/core.json'\n\nimport { RootState } from \"./store/rootReducer\";\nimport {\n  shouldShowPreview,\n  getCards,\n  getPanMode,\n} from \"./features/cards/cards.selectors\";\nimport { getCardsDataEntities } from \"./features/cards-data/cards-data.selectors\";\n\nconst mapStateToProps = (state: RootState) => {\n  return {\n    cards: getCards(state),\n    cardsData: getCardsDataEntities(state),\n    showPreview: shouldShowPreview(state),\n    panMode: getPanMode(state),\n  };\n};\n\nconst AppContainer = connect(mapStateToProps, {\n  cardMove,\n  endCardMove,\n  exhaustCard,\n  loadCardsData,\n  selectCard,\n  selectMultipleCards,\n  startCardMove,\n  unselectAllCards,\n  hoverCard,\n  hoverLeaveCard,\n  togglePanMode,\n  flipCards,\n})(App);\n\nexport default AppContainer;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import { combineReducers } from \"redux\";\nimport cards from \"../features/cards/cards.slice\";\nimport cardsData from \"../features/cards-data/cards-data.slice\";\n\nconst rootReducer = combineReducers({\n  cards,\n  cardsData,\n});\n\nexport type RootState = ReturnType<typeof rootReducer>;\n\nexport default rootReducer;\n","import {\n  configureStore as rtkConfigureStore,\n  getDefaultMiddleware,\n} from \"@reduxjs/toolkit\";\nimport rootReducer from \"./rootReducer\";\n\nconst customizedMiddleware = getDefaultMiddleware({\n  thunk: false,\n});\n\nexport default function configureStore() {\n  return rtkConfigureStore({\n    reducer: rootReducer,\n    middleware: customizedMiddleware,\n  });\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.scss\";\nimport { Provider } from \"react-redux\";\nimport AppContainer from \"./AppContainer\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport configureStore from \"./store/configureStore\";\n\nconst store = configureStore();\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <AppContainer />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}